<script>
    (function () {
        var secureFocusContainer = document.getElementById('individual-timed-session');
        var secureProgressLabel = document.getElementById('secure-progress-label');
        var secureCountdownEl = document.getElementById('secure-countdown');
        var secureTopbarTimer = document.getElementById('secure-topbar-timer');
        var timerVisibilityToggle = document.getElementById('timer-visibility-toggle');
        var questionProgressEl = document.getElementById('question-progress');
        var studentModeLabel = document.getElementById('student-mode-label');
        var questionLayout = document.getElementById('question-content');
        var questionVisual = document.getElementById('question-visual');
        var secureQuestionLayout = document.getElementById('secure-question-layout');
        var secureQuestionVisual = document.getElementById('secure-question-visual');
        var secureConnectionDot = document.getElementById('secure-connection-dot');
        var secureConnectionIndicator = document.getElementById('secure-connection-indicator');
        var secureConnectionStatus = document.getElementById('secure-connection-status');
        var secureConnectionWarning = document.getElementById('secure-connection-warning');
        var secureQuestionText = document.getElementById('secure-question-text');
        var secureQuestionSubline = document.getElementById('secure-question-subline');
        var secureQuestionImage = document.getElementById('secure-question-image');
        var secureOptionsList = document.getElementById('secure-options-list');
        var secureSubmitBtn = document.getElementById('secure-submit-btn');
        var secureSubmitLabel = document.getElementById('secure-submit-label');
        var secureSubmitHint = document.getElementById('secure-submit-hint');
        var secureConfidencePrompt = document.getElementById('secure-confidence-prompt');
        var timerHidden = false;
        var lastTimerDisplay = '00:00';
        var secureCountdownTotal = 0;
        var bodyEl = document.body;
        var secureCloseTimer = null;
        var firebaseDb = null;
        var firebaseRef = null;
        var studentKey = null;

        // --- FIREBASE INIT ---
        var currentFirebasePollId = null; // Store pollId for debug HUD
        var lastQuestionIndex = -1;

        // UUID Generator (Polyfill)
        function generateUUID() {
            if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
                return crypto.randomUUID();
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        async function initFirebaseSidecar(pollId, studentEmail) {
            if (!FIREBASE_CONFIG || !pollId || !studentEmail) return;

            if (typeof firebase !== 'undefined' && !firebase.apps.length) {
                firebase.initializeApp(FIREBASE_CONFIG);
            }

            if (typeof firebase !== 'undefined') {
                firebaseDb = firebase.database();
                // Deterministic key generation
                studentKey = await window.VeritasShared.generateStudentKey(studentEmail, pollId);
                currentFirebasePollId = pollId; // Store for debug HUD

                var path = 'sessions/' + pollId + '/students/' + studentKey;
                firebaseRef = firebaseDb.ref(path);

                // 1. Set Initial State with Read-Before-Write
                // Only set ACTIVE if current is null/undefined or DISCONNECTED.
                // Do NOT overwrite LOCKED or FINISHED.
                firebaseRef.once('value').then(function (snapshot) {
                    var current = snapshot.val();
                    if (!current || current === 'DISCONNECTED') {
                        firebaseRef.set('ACTIVE');
                    }
                });

                // 2. On Disconnect -> DISCONNECTED
                firebaseRef.onDisconnect().set('DISCONNECTED');

                // 3. Listen for changes (Remote Lock/Unlock)
                firebaseRef.on('value', function (snapshot) {
                    var status = snapshot.val();
                    handleRemoteStatusChange(status);
                    updateDebugHud(status, null, currentFirebasePollId);
                });

                // Connection State for HUD & Adaptive Polling
                firebaseDb.ref('.info/connected').on('value', function (snap) {
                    var connected = snap.val() === true;
                    updateDebugHud(null, connected, currentFirebasePollId);

                    // ADAPTIVE POLLING: Reduce server load when Firebase is active
                    // If connected, we receive "signals" for state changes, so we can poll slowly.
                    // If disconnected, we fallback to fast polling to ensure responsiveness.
                    if (connected) {
                        console.log('[Adaptive Polling] Firebase connected - switching to slow poll (15s)');
                        defaultPollInterval = 15000;
                    } else {
                        console.log('[Adaptive Polling] Firebase disconnected - switching to fast poll (2.5s)');
                        defaultPollInterval = 2500;
                    }
                });

                // 4. Signal-to-Poll: Listen for public state changes
                // When teacher advances slide, a signal is written here.
                // NEW: Listen to 'live_session' for instant updates (Hybrid Architecture)
                var liveSessionRef = firebaseDb.ref('sessions/' + pollId + '/live_session');
                liveSessionRef.on('value', function (snapshot) {
                    var data = snapshot.val();
                    if (data) {
                        console.log('[Firebase] Live Session update received:', data);

                        // If we have full metadata and a current pollId, update UI directly
                        if (data.metadata && data.pollId && typeof updateStudentView === 'function') {
                            console.log('[Firebase] Fast Path: Updating view from pushed state');
                            // Map Firebase data to state payload format
                            var statePayload = {
                                ...data.metadata,
                                pollId: data.pollId,
                                questionIndex: data.questionIndex,
                                status: data.status,
                                sessionPhase: data.sessionPhase || data.metadata.sessionPhase
                            };
                            updateStudentView(statePayload);
                        } else {
                            // Fallback to polling for full state if data is incomplete
                            console.log('[Firebase] Slow Path: Incomplete data, polling server');
                            startPolling(true);
                        }
                    }
                });

                console.log('[Firebase] Sidecar initialized for', path);
            }
        }

        /**
         * Submit answer directly to Firebase (Fast Path)
         */
        async function submitAnswerToFirebase(pollId, questionIndex, answer, confidence, email) {
            if (!firebaseDb) {
                console.warn('[Firebase] DB not initialized, skipping fast write');
                return null;
            }

            try {
                // Determine email if not provided
                var studentEmail = email || window.STUDENT_EMAIL || sessionStorage.getItem('veritas_student_email');
                if (!studentEmail) {
                    console.error('[Firebase] Cannot submit answer - no email found');
                    return null;
                }

                var responseId = generateUUID();
                var timestamp = new Date().toISOString();

                var payload = {
                    responseId: responseId,
                    pollId: pollId,
                    questionIndex: questionIndex,
                    answer: answer,
                    studentEmail: studentEmail,
                    confidenceLevel: confidence || null,
                    timestamp: timestamp,
                    clientTimestamp: Date.now()
                };

                // WRITE DIRECTLY TO FIREBASE (Scoped Path)
                // Path: sessions/{pollId}/responses/{questionIndex}/{safeEmail}
                var safeEmail = studentEmail.replace(/\./g, ','); // Firebase keys can't have '.'
                var path = 'sessions/' + pollId + '/responses/' + questionIndex + '/' + safeEmail;

                await firebaseDb.ref(path).set(payload);

                console.log('[Firebase] Fast Answer Submitted:', payload);
                return { success: true, responseId: responseId, timestamp: timestamp };
            } catch (e) {
                console.error('[Firebase] Fast Answer Failed:', e);
                return null;
            }
        }

        // =============================================================================
        // STUDENT ACTIVITY TRACKER MODULE
        // =============================================================================

        /**
         * Activity Tracker - Singleton for tracking granular student activity
         */
        var ActivityTracker = (function () {
            var instance = null;

            function createInstance() {
                var activityBuffer = [];
                var currentPollId = null;
                var currentSessionId = null;
                var currentQuestionIndex = null;
                var questionStartTime = null;
                var lastAnswer = null;
                var focusState = document.hasFocus();
                var flushInterval = null;
                var FLUSH_INTERVAL_MS = 3000; // Send batch every 3 seconds
                var MAX_BUFFER_SIZE = 50; // Flush if buffer exceeds 50 events

                function init(pollId, sessionId, questionIndex) {
                    currentPollId = pollId;
                    currentSessionId = sessionId || '';
                    currentQuestionIndex = questionIndex;
                    questionStartTime = Date.now();
                    lastAnswer = null;

                    // Start periodic flush
                    if (!flushInterval) {
                        flushInterval = setInterval(flushActivities, FLUSH_INTERVAL_MS);
                    }

                    // Track focus events
                    if (!window._activityTrackerFocusAttached) {
                        window.addEventListener('focus', onFocusGained);
                        window.addEventListener('blur', onFocusLost);
                        window._activityTrackerFocusAttached = true;
                    }

                    // Record question view
                    recordActivity('QUESTION_VIEW', {
                        viewedAt: Date.now(),
                        questionIndex: questionIndex
                    });
                }

                function setQuestionStart(timestamp) {
                    questionStartTime = timestamp || Date.now();
                }

                function recordActivity(eventType, eventData) {
                    if (!currentPollId) return;

                    var activity = {
                        pollId: currentPollId,
                        sessionId: currentSessionId,
                        questionIndex: currentQuestionIndex !== undefined ? currentQuestionIndex : '',
                        eventType: eventType,
                        eventData: eventData || {},
                        clientTimestamp: new Date().toISOString()
                    };

                    activityBuffer.push(activity);

                    // Flush if buffer is full
                    if (activityBuffer.length >= MAX_BUFFER_SIZE) {
                        flushActivities();
                    }
                }

                function recordAnswerSelected(answer, isChange) {
                    var eventType = isChange ? 'ANSWER_CHANGED' : 'ANSWER_SELECTED';
                    var timeOnQuestion = questionStartTime ? Date.now() - questionStartTime : 0;

                    recordActivity(eventType, {
                        answer: answer,
                        previousAnswer: lastAnswer,
                        timeOnQuestionMs: timeOnQuestion
                    });

                    lastAnswer = answer;
                }

                function recordAnswerSubmitted(answer, confidenceLevel) {
                    var timeOnQuestion = questionStartTime ? Date.now() - questionStartTime : 0;

                    recordActivity('ANSWER_SUBMITTED', {
                        answer: answer,
                        confidenceLevel: confidenceLevel || null,
                        timeOnQuestionMs: timeOnQuestion,
                        totalTimeMs: timeOnQuestion
                    });
                }

                function recordOptionClick(optionIndex, optionText) {
                    recordActivity('OPTION_CLICKED', {
                        optionIndex: optionIndex,
                        optionText: optionText
                    });
                }

                function onFocusGained() {
                    focusState = true;
                    recordActivity('FOCUS_GAINED', {
                        timestamp: Date.now()
                    });
                }

                function onFocusLost() {
                    focusState = false;
                    recordActivity('FOCUS_LOST', {
                        timestamp: Date.now()
                    });
                }

                function flushActivities() {
                    if (activityBuffer.length === 0 || !SESSION_TOKEN) return;

                    var toSend = activityBuffer.slice();
                    activityBuffer = [];

                    // Send batch to server
                    google.script.run
                        .withSuccessHandler(function () {
                            console.log('[ActivityTracker] Flushed ' + toSend.length + ' events');
                        })
                        .withFailureHandler(function (error) {
                            console.error('[ActivityTracker] Flush failed:', error);
                            // Re-add to buffer on failure (at front)
                            activityBuffer = toSend.concat(activityBuffer);
                        })
                        .recordActivitiesBatch(SESSION_TOKEN, toSend);
                }

                function reset() {
                    flushActivities(); // Flush before reset
                    currentPollId = null;
                    currentSessionId = null;
                    currentQuestionIndex = null;
                    questionStartTime = null;
                    lastAnswer = null;
                }

                function destroy() {
                    if (flushInterval) {
                        clearInterval(flushInterval);
                        flushInterval = null;
                    }
                    flushActivities(); // Final flush
                }

                return {
                    init: init,
                    setQuestionStart: setQuestionStart,
                    recordActivity: recordActivity,
                    recordAnswerSelected: recordAnswerSelected,
                    recordAnswerSubmitted: recordAnswerSubmitted,
                    recordOptionClick: recordOptionClick,
                    flushActivities: flushActivities,
                    reset: reset,
                    destroy: destroy
                };
            }

            return {
                getInstance: function () {
                    if (!instance) {
                        instance = createInstance();
                    }
                    return instance;
                }
            };
        })();

        // Global shorthand
        var activityTracker = ActivityTracker.getInstance();

        // =============================================================================
        // END ACTIVITY TRACKER
        // =============================================================================

        function updateDebugHud(status, connected, pollId) {
            if (!FIREBASE_CONFIG || !Veritas.Config.DEBUG_FIREBASE) return;

            var hud = document.getElementById('firebase-debug-hud');
            if (!hud) {
                hud = document.createElement('div');
                hud.id = 'firebase-debug-hud';
                hud.style.cssText = 'position:fixed;bottom:10px;left:10px;background:rgba(0,0,0,0.95);color:#4ade80;font-family:monospace;font-size:11px;padding:12px;z-index:9999;pointer-events:none;max-width:350px;border:2px solid #4ade80;border-radius:8px;';
                document.body.appendChild(hud);
            }

            // We store state on the DOM element dataset for merging updates
            if (status !== undefined && status !== null) hud.dataset.status = status;
            if (connected !== undefined && connected !== null) hud.dataset.connected = connected;
            if (pollId !== undefined && pollId !== null) hud.dataset.pollId = pollId;

            var currentStatus = hud.dataset.status || 'UNKNOWN';
            var isConnected = hud.dataset.connected === 'true';
            var currentPollId = hud.dataset.pollId || 'N/A';

            var connDot = isConnected ? '<span style="color:#4ade80">‚óè</span>' : '<span style="color:#f87171">‚óè</span>';
            var html = '<strong style="color:#fff">üî• FIREBASE DEBUG (STUDENT)</strong><br>';
            html += connDot + ' <strong>.info/connected:</strong> ' + isConnected + '<br>';
            html += '<strong>PollId (sessionKey):</strong> ' + currentPollId + '<br>';
            html += '<strong>StudentKey:</strong> ' + (studentKey ? studentKey.substring(0, 12) + '...' : 'N/A') + '<br>';

            var statusColor = currentStatus === 'LOCKED' ? '#f87171' : currentStatus === 'ACTIVE' ? '#4ade80' : '#facc15';
            html += '<strong>RTDB Status:</strong> <span style="color:' + statusColor + '">' + currentStatus + '</span><br>';

            // Show last violation reason
            var lockReason = '';
            try {
                lockReason = sessionStorage.getItem('lock_reason') || 'None';
            } catch (e) {
                lockReason = 'N/A';
            }
            html += '<strong>Last violation:</strong> ' + lockReason;

            hud.innerHTML = html;
        }

        function handleRemoteStatusChange(status) {
            console.log('[Firebase] Remote status update:', status);
            if (status === 'LOCKED') {
                // Server commanded lock
                if (!LockManager.isLocked()) {
                    LockManager.lock('Teacher Remote Lock');
                }
            } else if (status === 'ACTIVE') {
                // Teacher signalled unlock; defer to authoritative server confirmation
                // This prevents accidental unlocks from stale or spoofed RTDB writes.
                // FIX: Check both LockManager and Poison Pill state
                var isLocked = LockManager.isLocked() || isPoisonPillActive();
                if (isLocked) {
                    console.log('[Firebase] Unlock signal received - immediately checking server for AWAITING_FULLSCREEN');
                    // FIX: Immediately call checkProctorState instead of startPolling
                    // startPolling fails when poison pill is active, but we need to check for AWAITING_FULLSCREEN
                    checkProctorState();
                }
            }
        }

        function reportFirebaseViolation(reason, pollId) {
            // P0-4 FIX: Store lock reason in sessionStorage
            if (reason) {
                sessionStorage.setItem('lock_reason', reason);
            }

            // Extract pollId from available sources if not provided
            var activePollId = pollId ||
                (currentPollState && currentPollState.pollId) ||
                (secureLobbyContext && secureLobbyContext.pollId) ||
                window.currentPollId;

            // FALLBACK: Check sessionStorage
            if (!activePollId) {
                try {
                    activePollId = sessionStorage.getItem('veritas_active_poll_id');
                } catch (e) { /* Storage may be unavailable */ }
            }

            if (firebaseRef) {
                firebaseRef.set('LOCKED');

                // P0-3 FIX: Store violation reason in separate RTDB node for teacher visibility
                if (reason && activePollId && studentKey) {
                    var violationsRef = firebaseDb.ref('sessions/' + activePollId + '/violations/' + studentKey);
                    violationsRef.set({
                        reason: reason,
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                }
            }

            updateDebugHud('LOCKED', null, activePollId);
        }

        // ================================
        // UNIFIED ACTIVITY MONITOR
        // ================================
        var ActivityMonitor = (function () {
            var instance;

            function create() {
                var lastInteraction = Date.now();
                var currentQuestionStart = Date.now();
                var isCalculatorActive = false;

                function markInteraction() {
                    lastInteraction = Date.now();
                }

                function setQuestionStart(timestamp) {
                    currentQuestionStart = timestamp || Date.now();
                }

                function setCalculatorState(active) {
                    isCalculatorActive = !!active;
                }

                function getTelemetry() {
                    var now = Date.now();
                    var idleMs = now - lastInteraction;
                    var status = idleMs > 30000 ? 'IDLE' : (isCalculatorActive ? 'CALCULATOR' : 'ACTIVE');
                    return {
                        status: status,
                        lastInteraction: lastInteraction,
                        currentQuestionStart: currentQuestionStart,
                        timeOnQuestion: Math.max(0, now - currentQuestionStart),
                        usingCalculator: isCalculatorActive
                    };
                }

                function attachListeners() {
                    ['click', 'mousemove', 'keydown', 'touchstart'].forEach(function (evt) {
                        document.addEventListener(evt, markInteraction, { passive: true });
                    });
                    var calcFrame = document.getElementById('calc-iframe');
                    if (calcFrame) {
                        calcFrame.addEventListener('focus', function () { setCalculatorState(true); markInteraction(); });
                        calcFrame.addEventListener('blur', function () { setCalculatorState(false); });
                    }
                }

                attachListeners();

                return {
                    markInteraction: markInteraction,
                    setQuestionStart: setQuestionStart,
                    setCalculatorState: setCalculatorState,
                    getTelemetry: getTelemetry
                };
            }

            return {
                getInstance: function () {
                    if (!instance) {
                        instance = create();
                    }
                    return instance;
                }
            };
        })();

        var secureCountdownController = window.SecureAssessmentShared.createCountdown({
            onTick: function (seconds) {
                updateSecureTimerDisplay(seconds);
            },
            onExpire: function () {
                handleSecureTimeExpiry();
            }
        });
        var secureSessionHeartbeat = window.SecureAssessmentShared.createHeartbeat({
            intervalMs: 3500,
            onBeat: function () {
                pollForIndividualSessionState();
            }
        });
        var secureFullscreenManager = window.SecureAssessmentShared.createFullscreenManager(document, {
            onChange: handleSecureFullscreenChange
        });

        // Local session state guards (prevent UI rewind)
        var lastSubmittedQuestionIndex = null;
        var pendingMetacogQuestionIndex = null;
        var metacogSubmittedFor = null;

        if (timerVisibilityToggle) {
            timerVisibilityToggle.addEventListener('click', function () {
                timerHidden = !timerHidden;
                applyTimerVisibility();
            });
        }

        applyTimerVisibility();
        var secureSessionActive = false;
        var secureQuestionState = null;
        var secureSelectedOptionIndex = null;
        var secureCurrentQuestionKey = null;
        var secureSubmitting = false;
        var secureTimeExpired = false;
        var securePollInFlight = false;
        var secureMetacognitionEnabled = false;
        var securePendingAnswerText = null;

        // =============================================================================
        // SOVEREIGN STATE MANAGEMENT (Novel Approach)
        // =============================================================================

        var ViewManager = {
            views: [
                'entry-screen',
                'secure-lobby',
                'status-container',
                'pre-live-card',
                'student-container',
                'question-container',
                'individual-timed-session',
                'student-loader'
            ],
            show: function (viewId) {
                var self = this;

                // Special handling: 'student-container' wraps 'question-container', 'pre-live-card', etc.
                // If showing a child of student-container, we must also show student-container
                var isStudentContent = ['question-container', 'pre-live-card', 'status-container'].indexOf(viewId) !== -1;

                this.views.forEach(function (id) {
                    var el = document.getElementById(id);
                    if (!el) return;

                    if (id === viewId) {
                        el.style.display = 'block';
                        el.classList.remove('hidden');
                    } else if (id === 'student-container' && isStudentContent) {
                        // Ensure parent container is visible
                        el.style.display = 'block';
                        el.classList.remove('hidden');
                    } else {
                        el.style.display = 'none';
                        el.classList.add('hidden');
                    }
                });
                console.log('[ViewManager] Active View:', viewId);
            }
        };

        // Global Error Trapping
        window.onerror = function (msg, url, line, col, error) {
            var debugContent = document.getElementById('debug-content');
            if (debugContent) {
                var timestamp = new Date().toLocaleTimeString();
                debugContent.innerHTML += `\n[${timestamp}] ERROR: ${msg}\nLine: ${line}`;

                // Auto-show debug overlay on critical errors if safe
                var overlay = document.getElementById('debug-overlay');
                if (overlay && msg.indexOf('ScriptError') === -1) { // Ignore common script interruptions
                    overlay.classList.remove('hidden');
                }
            }
            return false;
        };

        var LockManager = {
            isLocked: function () {
                try {
                    return sessionStorage.getItem('veritas_lock_active') === 'true';
                } catch (e) { return false; }
            },
            lock: function (reason) {
                console.warn('[LockManager] LOCKING:', reason);
                try {
                    sessionStorage.setItem('veritas_lock_active', 'true');
                    sessionStorage.setItem('lock_reason', reason || 'unknown');
                } catch (e) { }

                this.renderLockScreen(reason);

                // FIX: Report violation with proper error handling and retry logic
                // Use robust pollId resolution with sessionStorage fallback
                var activePollId = (typeof currentPollState !== 'undefined' && currentPollState && currentPollState.pollId) ||
                    (typeof secureLobbyContext !== 'undefined' && secureLobbyContext && secureLobbyContext.pollId) ||
                    (typeof secureQuestionState !== 'undefined' && secureQuestionState && secureQuestionState.pollId) ||
                    window.currentPollId;

                // CRITICAL FALLBACK: Check sessionStorage for pollId
                if (!activePollId) {
                    try {
                        activePollId = sessionStorage.getItem('veritas_active_poll_id');
                    } catch (e) { /* Storage may be unavailable */ }
                }

                if (!activePollId) {
                    console.error('[LockManager] CRITICAL: No pollId available for violation report!');
                    return;
                }

                // Update Firebase immediately for instant teacher feedback
                if (typeof reportFirebaseViolation === 'function') {
                    reportFirebaseViolation(reason, activePollId);
                }

                // CRITICAL FIX: Get fallback email for robust student identification
                // This ensures violations are attributed correctly even if SESSION_TOKEN is lost
                var fallbackEmail = window.STUDENT_EMAIL || '';
                if (!fallbackEmail) {
                    try {
                        fallbackEmail = sessionStorage.getItem('veritas_student_email') || '';
                    } catch (e) { /* Storage may be unavailable */ }
                }

                // Report to server with proper handlers and retry logic
                var self = this;
                var retryCount = 0;
                var maxRetries = 3;

                function reportToServer() {
                    if (!window.google || !google.script) {
                        console.error('[LockManager] google.script not available');
                        return;
                    }

                    console.log('[LockManager] Reporting violation to server (attempt ' + (retryCount + 1) + '):', activePollId, reason, 'fallbackEmail:', fallbackEmail ? '[provided]' : '[none]');

                    google.script.run
                        .withSuccessHandler(function (response) {
                            if (response && response.success) {
                                console.log('[LockManager] Violation reported successfully:', response);
                                if (response.lockVersion !== undefined) {
                                    currentLockVersion = response.lockVersion;
                                }
                            } else {
                                console.error('[LockManager] Server rejected violation report:', response);
                                // Retry on failure
                                if (retryCount < maxRetries) {
                                    retryCount++;
                                    setTimeout(reportToServer, 1000 * retryCount);
                                }
                            }
                        })
                        .withFailureHandler(function (error) {
                            console.error('[LockManager] Violation report failed:', error);
                            // Retry on network failure
                            if (retryCount < maxRetries) {
                                retryCount++;
                                setTimeout(reportToServer, 1000 * retryCount);
                            }
                        })
                        .reportStudentViolation(activePollId, SESSION_TOKEN || '', reason || 'lock', fallbackEmail);
                }

                reportToServer();
            },
            unlock: function () {
                console.log('[LockManager] UNLOCKING');
                try {
                    sessionStorage.removeItem('veritas_lock_active');
                    sessionStorage.removeItem('lock_reason');
                } catch (e) { }
                hideLockEnforcementUI();
            },
            renderLockScreen: function (reason) {
                // Use the new Hybrid UI - pass reason to showLockEnforcementUI
                showLockEnforcementUI(reason);
            }
        };

        // =============================================================================
        // ZERO TOLERANCE PROCTORING - Helper Functions
        // =============================================================================

        /**
         * Determines if proctoring should be enabled for the session
         * Returns true if sessionType === 'SECURE_ASSESSMENT' OR metadata.liveProctoring === true
         * @param {Object} metadata - Session metadata containing sessionType and liveProctoring flag
         * @returns {boolean} True if proctoring should be enabled
         */
        function shouldEnableProctoring(metadata) {
            if (!metadata) return false;
            // Check for secure assessment
            var sessionType = (metadata.sessionType || '').toString().toUpperCase();
            if (sessionType === 'SECURE_ASSESSMENT' || sessionType === 'SECURE') {
                return true;
            }
            // Check for live proctoring enabled on Live Poll
            if (metadata.liveProctoring === true) {
                return true;
            }
            return false;
        }

        /**
         * AGGRESSIVE LOCKING - Zero Tolerance Implementation
         * Immediately locks the session with no grace period, no warnings.
         * - Hides question UI
         * - Shows red "LOCKED" overlay
         * - Persists lock to sessionStorage to prevent refresh bypass ("Poison Pill")
         * - Sends priority violation report to server
         * @param {string} reason - The violation reason (e.g., 'exit-fullscreen', 'tab-blur')
         */
        function lockSession(reason) {
            console.log('[Proctor] LOCK SESSION triggered:', reason);

            // IMMEDIATELY block all interaction
            isInteractionBlocked = true;
            violationLogged = true;

            // POISON PILL: Persist lock state to sessionStorage to prevent refresh bypass
            // This key MUST be checked at the top of startPolling() and updateStudentView()
            // The ONLY way to clear this is when server sends unlock_granted: true
            try {
                sessionStorage.setItem('veritas_lock_active', 'true');
                sessionStorage.setItem('is_locally_locked', 'true');
                sessionStorage.setItem('lock_reason', reason || 'violation');
                sessionStorage.setItem('lock_timestamp', Date.now().toString());
            } catch (e) {
                console.warn('[Proctor] Could not persist lock to sessionStorage:', e);
            }

            // Hide question UI - prevent seeing answers during lock
            if (secureOptionsList) {
                secureOptionsList.style.visibility = 'hidden';
            }
            if (secureQuestionText) {
                secureQuestionText.style.visibility = 'hidden';
            }
            if (secureQuestionImage) {
                secureQuestionImage.style.visibility = 'hidden';
            }

            // Show lock overlay with professional messaging
            showLockEnforcementUI();

            // Send priority violation report to server
            var activePollId = (currentPollState && currentPollState.pollId) ||
                (secureLobbyContext && secureLobbyContext.pollId) ||
                (secureQuestionState && secureQuestionState.pollId);

            // CRITICAL FIX: Get fallback email for robust student identification
            var fallbackEmail = window.STUDENT_EMAIL || '';
            if (!fallbackEmail) {
                try { fallbackEmail = sessionStorage.getItem('veritas_student_email') || ''; } catch (e) { }
            }

            if (activePollId) {
                google.script.run
                    .withSuccessHandler(function (response) {
                        console.log('[Proctor] Lock violation reported to server:', response);
                        if (response && response.success) {
                            currentLockVersion = response.lockVersion;
                        }
                        startProctorPolling();
                    })
                    .withFailureHandler(function (error) {
                        console.error('[Proctor] Failed to report lock violation:', error);
                        startProctorPolling();
                    })
                    .reportStudentViolation(activePollId, SESSION_TOKEN, reason || 'session-locked', fallbackEmail);
            }
        }

        /**
         * Check if session was locked before (e.g., page refresh bypass attempt)
         * Called on page load to restore lock state
         * POISON PILL: Uses veritas_lock_active which can ONLY be cleared by server unlock_granted
         */
        function checkForPersistedLock() {
            try {
                // PRIMARY CHECK: veritas_lock_active is the "Poison Pill" key
                var poisonPillActive = sessionStorage.getItem('veritas_lock_active');
                var isLocked = sessionStorage.getItem('is_locally_locked');

                if (poisonPillActive === 'true' || isLocked === 'true') {
                    var lockReason = sessionStorage.getItem('lock_reason') || 'previous-violation';
                    console.log('[Proctor] POISON PILL ACTIVE - Restoring lock state from sessionStorage:', lockReason);
                    isInteractionBlocked = true;
                    violationLogged = true;
                    showLockEnforcementUI();
                    // Start proctor polling to wait for server unlock
                    startProctorPolling();
                    return true;
                }
            } catch (e) {
                console.warn('[Proctor] Could not check sessionStorage for lock:', e);
            }
            return false;
        }

        /**
         * Clear the persisted lock state (called ONLY when server sends unlock_granted: true)
         * This is the ONLY "antidote" to the Poison Pill
         */
        function clearPersistedLock() {
            try {
                console.log('[Proctor] ANTIDOTE - Clearing Poison Pill lock state');
                sessionStorage.removeItem('veritas_lock_active');
                sessionStorage.removeItem('is_locally_locked');
                sessionStorage.removeItem('lock_reason');
                sessionStorage.removeItem('lock_timestamp');
            } catch (e) {
                console.warn('[Proctor] Could not clear lock from sessionStorage:', e);
            }
        }

        /**
 * POISON PILL CHECK - Uses both sessionStorage and localStorage for maximum persistence
 */
        function isPoisonPillActive() {
            try {
                return sessionStorage.getItem('veritas_lock_active') === 'true';
            } catch (e) {
                return false;
            }
        }

        /**
         * Set the persistent lock state
         */
        function setPoisonPill(active) {
            try {
                if (active) {
                    sessionStorage.setItem('veritas_lock_active', 'true');
                } else {
                    sessionStorage.removeItem('veritas_lock_active');
                }
            } catch (e) {
                console.error('Failed to set poison pill', e);
            }
        }

        // =============================================================================
        // STORE-AND-FORWARD DATA LAYER - AnswerQueue
        // =============================================================================

        /**
         * AnswerQueue - Guarantees exam integrity by storing answers locally before sync
         * Uses localStorage for persistence across network failures
         * Implements optimistic UI with background sync
         */
        var AnswerQueue = (function () {
            var QUEUE_PREFIX = 'veritas_queue_';
            var SYNC_INTERVAL = 2000; // 2 seconds
            var syncIntervalId = null;
            var isSyncing = false;

            /**
             * Get the localStorage key for the current session
             */
            function getQueueKey(sessionId) {
                return QUEUE_PREFIX + (sessionId || 'default');
            }

            /**
             * Read the queue from localStorage
             */
            function readQueue(sessionId) {
                try {
                    var key = getQueueKey(sessionId);
                    var raw = localStorage.getItem(key);
                    if (raw) {
                        return JSON.parse(raw);
                    }
                } catch (e) {
                    console.error('[AnswerQueue] Failed to read queue:', e);
                }
                return [];
            }

            /**
             * Write the queue to localStorage
             */
            function writeQueue(sessionId, queue) {
                try {
                    var key = getQueueKey(sessionId);
                    localStorage.setItem(key, JSON.stringify(queue));
                } catch (e) {
                    console.error('[AnswerQueue] Failed to write queue:', e);
                }
            }

            /**
             * Push an answer to the queue
             * @param {Object} payload - Answer payload (pollId, sessionId, questionIndex, answer, confidenceLevel)
             */
            function push(payload) {
                if (!payload || !payload.sessionId) {
                    console.warn('[AnswerQueue] Cannot push without sessionId');
                    return;
                }
                var queue = readQueue(payload.sessionId);
                // Add metadata for tracking
                payload.queuedAt = Date.now();
                payload.syncAttempts = 0;
                queue.push(payload);
                writeQueue(payload.sessionId, queue);
                console.log('[AnswerQueue] Answer queued:', payload.actualQuestionIndex);
            }

            /**
             * Get pending items count
             */
            function getPendingCount(sessionId) {
                return readQueue(sessionId).length;
            }

            /**
             * Process and sync queued answers to server
             * Called periodically by sync loop
             */
            function syncToServer(sessionId, onSuccess, onError) {
                if (isSyncing) {
                    console.log('[AnswerQueue] Sync already in progress, skipping');
                    return;
                }

                var queue = readQueue(sessionId);
                if (queue.length === 0) {
                    return;
                }

                isSyncing = true;
                var item = queue[0]; // Process first item (FIFO)
                item.syncAttempts = (item.syncAttempts || 0) + 1;

                console.log('[AnswerQueue] Syncing answer:', item.actualQuestionIndex, 'attempt:', item.syncAttempts);

                google.script.run
                    .withSuccessHandler(function (response) {
                        isSyncing = false;
                        if (response && response.success) {
                            // Remove successfully synced item from queue
                            queue.shift();
                            writeQueue(sessionId, queue);
                            console.log('[AnswerQueue] Answer synced successfully:', item.actualQuestionIndex);
                            if (onSuccess) onSuccess(response, item);
                            // Continue syncing remaining items
                            if (queue.length > 0) {
                                setTimeout(function () {
                                    syncToServer(sessionId, onSuccess, onError);
                                }, 100);
                            }
                        } else {
                            // Server returned error but request completed
                            console.warn('[AnswerQueue] Server rejected answer:', response);
                            // Check if this is a "already answered" error - remove from queue
                            var errorMsg = (response && response.error) || '';
                            if (/already answered|non-current question/i.test(errorMsg)) {
                                queue.shift();
                                writeQueue(sessionId, queue);
                            }
                            if (onError) onError(response, item);
                        }
                    })
                    .withFailureHandler(function (error) {
                        isSyncing = false;
                        console.error('[AnswerQueue] Sync failed:', error);
                        // Keep item in queue for retry, update queue with new attempt count
                        writeQueue(sessionId, queue);
                        if (onError) onError(error, item);
                    })
                    .submitIndividualTimedAnswer(
                        item.pollId,
                        item.sessionId,
                        item.actualQuestionIndex,
                        item.answer,
                        SESSION_TOKEN,
                        item.confidenceLevel
                    );
            }

            /**
             * Start the background sync loop
             */
            function startSyncLoop(sessionId, onSuccess, onError) {
                if (syncIntervalId) {
                    console.log('[AnswerQueue] Sync loop already running');
                    return;
                }
                console.log('[AnswerQueue] Starting sync loop for session:', sessionId);
                syncIntervalId = setInterval(function () {
                    syncToServer(sessionId, onSuccess, onError);
                }, SYNC_INTERVAL);
            }

            /**
             * Stop the sync loop
             */
            function stopSyncLoop() {
                if (syncIntervalId) {
                    clearInterval(syncIntervalId);
                    syncIntervalId = null;
                    console.log('[AnswerQueue] Sync loop stopped');
                }
            }

            /**
             * Clear the queue for a session (e.g., when session ends)
             */
            function clear(sessionId) {
                try {
                    var key = getQueueKey(sessionId);
                    localStorage.removeItem(key);
                    console.log('[AnswerQueue] Queue cleared for session:', sessionId);
                } catch (e) {
                    console.error('[AnswerQueue] Failed to clear queue:', e);
                }
            }

            // Public API
            return {
                push: push,
                getPendingCount: getPendingCount,
                syncToServer: syncToServer,
                startSyncLoop: startSyncLoop,
                stopSyncLoop: stopSyncLoop,
                clear: clear,
                readQueue: readQueue
            };
        })();

        function getModeName() {
            return secureSessionActive ? 'Assessment' : 'Poll';
        }

        function getModeNameLowerCase() {
            return secureSessionActive ? 'assessment' : 'poll';
        }

        function getFullModeName() {
            return secureSessionActive ? 'Secure Assessment' : 'Live Poll';
        }

        function setSecureChromeState(isActive) {
            if (studentModeLabel) {
                studentModeLabel.textContent = isActive ? 'Secure Assessment' : 'Live Poll';
            }
            if (secureTopbarTimer) {
                secureTopbarTimer.classList.toggle('hidden', !isActive);
                // Defensive: Ensure timer is visible and has initial content
                if (isActive && secureCountdownEl) {
                    secureCountdownEl.textContent = lastTimerDisplay || '00:00';
                }
            }
        }

        function formatTime(seconds) {
            var minutes = Math.floor(seconds / 60);
            var remainingSeconds = seconds % 60;
            return ('0' + minutes).slice(-2) + ':' + ('0' + remainingSeconds).slice(-2);
        }

        function updateQuestionProgress(currentIndex, totalQuestions) {
            if (!questionProgressEl) return;
            var parsedIndex = typeof currentIndex === 'number' ? currentIndex : parseInt(currentIndex, 10);
            var parsedTotal = typeof totalQuestions === 'number' ? totalQuestions : parseInt(totalQuestions, 10);

            // Fix: Handle '?' and ensure 1-based indexing
            var safeIndex = isNaN(parsedIndex) ? 0 : Math.max(0, parsedIndex);
            var safeTotal = isNaN(parsedTotal) || parsedTotal <= 0 ? '?' : Math.max(1, parsedTotal);

            questionProgressEl.textContent = 'QUESTION ' + (safeIndex + 1) + ' OF ' + safeTotal;

            // Ensure visibility
            questionProgressEl.classList.remove('hidden');
        }

        function deriveSecureQuestionKey(state) {
            if (!state || !state.question) {
                return null;
            }
            if (state.question.id) {
                return state.question.id;
            }
            if (state.question.questionId) {
                return state.question.questionId;
            }
            if (typeof state.actualQuestionIndex === 'number') {
                return (state.pollId || 'poll') + ':' + state.actualQuestionIndex;
            }
            return (state.pollId || 'poll') + ':' + (state.progressIndex || 0);
        }

        function toggleSecureLayout(active) {
            if (!bodyEl) return;
            bodyEl.classList.toggle('secure-mode-active', !!active);
        }

        function hideExitControls() {
            if (!secureExitControls) return;
            secureExitControls.classList.add('hidden');
        }

        function showExitControls(label, description) {
            if (!secureExitControls) return;
            secureExitControls.classList.remove('hidden');
            if (secureExitLabel) {
                secureExitLabel.textContent = label || 'Exit Session';
            }
            if (secureExitDescription) {
                secureExitDescription.textContent = description || 'Exit fullscreen and close this tab when you are finished.';
            }
        }

        function setSecureConnectionIndicatorVisible(visible) {
            if (!secureConnectionIndicator) return;
            if (visible) {
                secureConnectionIndicator.classList.remove('hidden');
            } else {
                secureConnectionIndicator.classList.add('hidden');
            }
        }

        function syncSecureOptionSelection() {
            if (!secureOptionsList) return;
            var buttons = secureOptionsList.querySelectorAll('button.secure-answer-option');
            buttons.forEach(function (btn) {
                var btnIndex = parseInt(btn.dataset.optionIndex, 10);
                var selected = btnIndex === secureSelectedOptionIndex;
                btn.classList.toggle('answer-option-selected', selected);
                btn.setAttribute('aria-pressed', selected ? 'true' : 'false');
            });
        }

        function showIndividualTimedView(state) {
            // FIX TASK B: LOCK GUARD - If locked, do not show question view
            // This prevents lock bypass via view updates or server state changes
            if (LockManager.isLocked()) {
                console.log('[Proctor] showIndividualTimedView BLOCKED - Lock active');
                LockManager.renderLockScreen(sessionStorage.getItem('lock_reason'));
                return; // HALT RENDER - SECURITY BLOCK
            }

            // FIX: Force hide ALL other screens to prevent "Start Screen Leak" cheating risk
            hideSecureLobby();
            if (studentLoader) studentLoader.style.display = 'none';
            if (entryScreen) entryScreen.style.display = 'none';
            if (secureLobbyCard) secureLobbyCard.style.display = 'none';
            studentContainer.style.display = 'block';
            questionContainer.style.display = 'none';
            statusContainer.style.display = 'none';
            if (preLiveCard) preLiveCard.style.display = 'none';
            if (secureFocusContainer) secureFocusContainer.style.display = 'block';

            // FIX: SCROLL LOCK - Prevent scrolling to any leaked content
            document.body.style.overflow = 'hidden';

            toggleSecureLayout(true);
            if (!secureSessionActive) {
                secureSessionActive = true;
                secureSessionHeartbeat.start(true);
            }
            setSecureChromeState(true);

            // Sync calculator visibility based on server state
            syncCalculatorVisibility(state.calculatorEnabled);

            // FIX: Explicitly show timer container - defensive check
            if (secureTopbarTimer) {
                secureTopbarTimer.classList.remove('hidden');
            }

            hideSecureOverlay();
            setSecureConnectionIndicatorVisible(true);
            attachProctorVisibilityListeners();
            secureQuestionState = state;

            // CRITICAL: Persist pollId for violation reporting (secure question path)
            if (state && state.pollId) {
                window.currentPollId = state.pollId;
                try {
                    sessionStorage.setItem('veritas_active_poll_id', state.pollId);
                } catch (e) { /* Storage may be unavailable */ }
            }

            if (entryScreen) entryScreen.style.display = 'none';
            if (secureLobbyCard) secureLobbyCard.style.display = 'none';
            var nextQuestionKey = deriveSecureQuestionKey(state);
            var isNewQuestion = secureCurrentQuestionKey !== nextQuestionKey;
            secureCurrentQuestionKey = nextQuestionKey;
            if (isNewQuestion) {
                secureSelectedOptionIndex = null;
                securePendingAnswerText = null;
                secureMetacognitionEnabled = false;
                hideSecureConfidencePrompt();
                ActivityMonitor.getInstance().setQuestionStart(Date.now());
            }
            secureSubmitting = false;
            secureTimeExpired = false;
            disableSecureOptions(false);

            // FIX: More robust question progress with debug logging
            if (questionProgressEl) {
                var progressIdx = typeof state.progressIndex === 'number'
                    ? state.progressIndex
                    : (typeof state.currentQuestionIndex === 'number' ? state.currentQuestionIndex : 0);
                var totalCount = typeof state.totalQuestions === 'number'
                    ? state.totalQuestions
                    : (state.question && state.question.options ? state.question.options.length : 1);
                console.log('[Secure] Question progress:', { progressIdx: progressIdx, totalCount: totalCount, state: state });
                questionProgressEl.textContent = 'QUESTION ' + (progressIdx + 1) + ' OF ' + totalCount;
            } else {
                console.warn('[Secure] questionProgressEl not found');
            }

            renderSecureQuestion(state);
            startSecureCountdown(state.timeRemainingSeconds || 0);
            updateSecureConnectionIndicators(state);
        }

        function renderSecureQuestion(state) {
            if (!state) return;

            // FIX TASK B: LOCK GUARD - If locked, do not render question content
            // This prevents lock bypass via question navigation or view refresh
            if (LockManager.isLocked()) {
                console.log('[Proctor] renderSecureQuestion BLOCKED - Lock active');
                LockManager.renderLockScreen(sessionStorage.getItem('lock_reason'));
                return; // HALT RENDER - SECURITY BLOCK
            }

            // Capture metacognition setting for this question
            secureMetacognitionEnabled = !!(state.question && state.question.metacognitionEnabled);
            var progressValue = typeof state.progressIndex === 'number'
                ? state.progressIndex
                : (typeof state.currentQuestionIndex === 'number' ? state.currentQuestionIndex : 0);
            var totalValue = typeof state.totalQuestions === 'number' ? state.totalQuestions : (state.question && state.question.options ? state.question.options.length : 0);
            if (secureProgressLabel) {
                secureProgressLabel.textContent = 'Question ' + (progressValue + 1) + ' of ' + totalValue;
            }
            updateQuestionProgress(progressValue, totalValue);
            if (secureQuestionText) {
                secureQuestionText.textContent = state.question.questionText || '';
            }
            if (secureQuestionSubline) {
                secureQuestionSubline.classList.add('hidden');
                secureQuestionSubline.textContent = '';
            }
            if (secureQuestionImage) {
                if (state.question.questionImageURL) {
                    secureQuestionImage.src = state.question.questionImageURL;
                    secureQuestionImage.style.display = 'block';
                } else {
                    secureQuestionImage.style.display = 'none';
                }
            }
            var secureHasImage = !!state.question.questionImageURL;
            if (secureQuestionLayout) {
                secureQuestionLayout.classList.toggle('no-image', !secureHasImage);
            }
            if (secureQuestionVisual) {
                secureQuestionVisual.style.display = secureHasImage ? 'flex' : 'none';
            }
            if (secureOptionsList) {
                secureOptionsList.innerHTML = '';
                var letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                var options = Array.isArray(state.question.options) ? state.question.options : [];
                options.forEach(function (option, index) {
                    secureOptionsList.appendChild(buildSecureOption(option, index, letters.charAt(index) || '#'));
                });
                syncSecureOptionSelection();
            }
            updateSecureSubmitState();
        }

        function buildSecureOption(option, index, letter) {
            var li = document.createElement('li');
            var button = document.createElement('button');
            button.type = 'button';
            button.className = 'answer-option secure-answer-option relative w-full text-left';
            button.dataset.optionIndex = index;
            button.setAttribute('aria-pressed', 'false');
            var displayText = (option && option.text) ? option.text.toString() : '';
            var cleanText = displayText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            var content = '';
            if (option && option.imageURL) {
                content += '<img src="' + escapeHtml(option.imageURL) + '" alt="Answer ' + letter + '" class="option-image" referrerpolicy="no-referrer">';
            }
            content += '<div class="option-leading">';
            content += '<div class="letter-badge" aria-hidden="true">' + letter + '</div>';
            content += '<div class="option-body">';
            content += '<div class="option-text-wrapper">';
            if (cleanText) {
                content += '<p class="option-text">' + escapeHtml(cleanText).replace(/\n/g, '<br>') + '</p>';
            }
            content += '<span class="result-ribbon"></span>';
            content += '<span class="sr-only secure-selection-announcement"></span>';
            content += '</div>';
            content += '<span class="percentage-bubble"></span>';
            content += '</div>';
            content += '</div>';
            content += '<span class="result-indicator" aria-hidden="true"></span>';
            button.innerHTML = content;
            button.addEventListener('click', function (event) {
                if (event && event.target && event.target.closest('.option-image')) {
                    return;
                }
                handleSecureOptionSelect(index);
            });
            li.appendChild(button);
            return li;
        }

        function handleSecureOptionSelect(index) {
            if (!secureOptionsList) return;
            secureSelectedOptionIndex = index;
            syncSecureOptionSelection();
            updateSecureSubmitState();
        }

        function updateSecureSubmitState() {
            if (!secureSubmitBtn) return;
            var hasState = !!secureQuestionState;
            var disabled = !hasState || secureSubmitting || secureTimeExpired;
            secureSubmitBtn.disabled = disabled;
            secureSubmitBtn.classList.toggle('opacity-60', disabled);
            if (secureSubmitLabel && hasState && !secureSubmitting) {
                var onLastQuestion = secureQuestionState.progressIndex >= secureQuestionState.totalQuestions - 1;
                secureSubmitLabel.textContent = onLastQuestion ? 'Submit Exam' : 'Submit & Next';
            }
            if (secureSubmitHint) {
                if (!hasState) {
                    secureSubmitHint.textContent = '';
                } else if (typeof secureSelectedOptionIndex === 'number') {
                    var letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    var letter = letters.charAt(secureSelectedOptionIndex) || '#';
                    secureSubmitHint.textContent = 'Selected ' + letter + '. Submit when ready.';
                } else {
                    secureSubmitHint.textContent = 'No answer selected ‚Äî submitting will record this as blank.';
                }
            }
        }

        function setSecureSubmitLoading(isLoading) {
            secureSubmitting = isLoading;
            if (!secureSubmitBtn) return;
            secureSubmitBtn.disabled = isLoading;
            secureSubmitBtn.classList.toggle('opacity-60', isLoading);
            if (secureSubmitLabel && isLoading) {
                secureSubmitLabel.textContent = 'Saving...';
            }
            if (!isLoading) {
                updateSecureSubmitState();
            }
        }

        function disableSecureOptions(disabled) {
            if (!secureOptionsList) return;
            secureOptionsList.querySelectorAll('button.secure-answer-option').forEach(function (btn) {
                btn.disabled = disabled;
                btn.classList.toggle('answer-option-disabled', disabled);
            });
        }

        function submitIndividualAnswer(state, answerText, isAutoSubmit) {
            if (!state || secureSubmitting) return;

            // Check if metacognition is enabled for this question
            // Auto-submits (timeout, forced submission) bypass the confidence prompt
            if (secureMetacognitionEnabled && !isAutoSubmit) {
                console.log('Metacognition enabled - showing confidence prompt');
                showSecureConfidencePrompt(answerText);
                return; // Don't submit yet, wait for confidence selection
            }

            // No metacognition or auto-submit, submit directly with null confidence
            submitIndividualAnswerWithConfidence(state, answerText, null);
        }

        function submitIndividualAnswerWithConfidence(state, answerText, confidenceLevel, retryCount) {
            retryCount = retryCount || 0;
            var maxRetries = 3;

            if (!state || secureSubmitting) return;
            setSecureSubmitLoading(true);
            disableSecureOptions(true);
            var answerDetails = {
                pollId: state.pollId,
                sessionId: state.sessionId,
                actualQuestionIndex: state.actualQuestionIndex,
                answer: answerText || '',
                confidenceLevel: confidenceLevel
            };

            var telemetry = ActivityMonitor.getInstance().getTelemetry();

            // FAST PATH: Write to Firebase first (Optimistic UI)
            submitAnswerToFirebase(
                answerDetails.pollId,
                answerDetails.actualQuestionIndex,
                answerDetails.answer,
                answerDetails.confidenceLevel,
                null // let function derive email
            ).then(function (fbResult) {
                if (fbResult && fbResult.success) {
                    console.log('Firebase write success, proceeding with optimistic UI update');

                    // Optimistic Success: Clear local state and show loading next
                    try { localStorage.removeItem('secure_pending_answer'); } catch (e) { }

                    setSecureSubmitLoading(false);
                    disableSecureOptions(false);
                    hideSecureConfidencePrompt();

                    secureSelectedOptionIndex = null;
                    secureQuestionState = null;
                    secureCurrentQuestionKey = null;

                    if (secureQuestionText) {
                        secureQuestionText.innerHTML = '<div style="display: flex; align-items: center; gap: 12px; padding: 20px 0;"><div style="width: 24px; height: 24px; border: 3px solid rgba(18, 56, 93, 0.2); border-top-color: #12385d; border-radius: 50%; animation: veritas-spin 0.7s linear infinite;"></div><span style="color: #4b5563; font-size: 1.1rem;">Answer Saved. Loading next...</span></div>';
                    }
                    if (secureQuestionImage) secureQuestionImage.style.display = 'none';
                    if (secureOptionsList) secureOptionsList.innerHTML = '';

                    // Trigger server sync in background (fire and forget for UI, but important for persistence)
                    // FIX: Pass the client-generated responseId to ensure deduplication works server-side
                    google.script.run
                        .withSuccessHandler(function () {
                            console.log('Server sync confirmed');
                            // We can poll here to get the next question officially
                            setTimeout(function () { pollForIndividualSessionState(); }, 50);
                        })
                        .withFailureHandler(function (e) {
                            console.warn('Server sync failed (data safe in Firebase):', e);
                            // Still poll to try and get next question if network recovers
                            setTimeout(function () { pollForIndividualSessionState(); }, 2000);
                        })
                        .submitIndividualTimedAnswer(
                            answerDetails.pollId,
                            answerDetails.sessionId,
                            answerDetails.actualQuestionIndex,
                            answerDetails.answer,
                            SESSION_TOKEN,
                            answerDetails.confidenceLevel,
                            fbResult.responseId // PASS UUID HERE
                        );
                } else {
                    console.warn('Firebase write failed/skipped, falling back to legacy server path');
                    fallbackSubmitToServer(answerDetails, retryCount, maxRetries);
                }
            });
        }

        function fallbackSubmitToServer(answerDetails, retryCount, maxRetries) {
            google.script.run
                .withSuccessHandler(function (response) {
                    setSecureSubmitLoading(false);
                    disableSecureOptions(false);
                    hideSecureConfidencePrompt(); // Ensure hidden on success
                    if (response && response.success) {
                        // Success - clear local backup
                        try {
                            localStorage.removeItem('secure_pending_answer');
                        } catch (e) {
                            console.warn('Could not clear local backup', e);
                        }

                        // Clear current question state immediately to prevent re-display
                        var previousQuestionKey = secureCurrentQuestionKey;
                        secureSelectedOptionIndex = null;
                        secureQuestionState = null;
                        secureCurrentQuestionKey = null;

                        // Show loading state instead of blank screen
                        if (secureQuestionText) {
                            secureQuestionText.innerHTML = '<div style="display: flex; align-items: center; gap: 12px; padding: 20px 0;"><div style="width: 24px; height: 24px; border: 3px solid rgba(18, 56, 93, 0.2); border-top-color: #12385d; border-radius: 50%; animation: veritas-spin 0.7s linear infinite;"></div><span style="color: #4b5563; font-size: 1.1rem;">Loading next question...</span></div>';
                        }
                        if (secureQuestionImage) secureQuestionImage.style.display = 'none';
                        if (secureOptionsList) secureOptionsList.innerHTML = '';

                        // Immediate polling to load next question faster
                        setTimeout(function () {
                            pollForIndividualSessionState();
                        }, 100);
                    } else {
                        // If server says non-current question, resync immediately
                        var errorMessage = (response && response.error) || 'Failed to submit answer.';
                        if (/non-current question/i.test(errorMessage)) {
                            console.warn('Sync mismatch detected (non-current question). Force resyncing state.');
                            pollForIndividualSessionState();
                            return; // Skip handleError to avoid alerting user during auto-recovery
                        }
                        handleError(errorMessage);
                    }
                })
                .withFailureHandler(function (error) {
                    // Check if network error and retries available
                    var isNetworkError = /network|timeout|unavailable|DNS|failed to fetch/i.test(error.toString());

                    if (isNetworkError && retryCount < maxRetries) {
                        console.warn('Submission failed, retrying... (' + (retryCount + 1) + '/' + maxRetries + ')');

                        // Exponential backoff: 1s, 2s, 4s
                        var delay = Math.pow(2, retryCount) * 1000;

                        setTimeout(function () {
                            setSecureSubmitLoading(false); // Reset to allow retry
                            secureSubmitting = false; // Important: reset locking flag
                            fallbackSubmitToServer(answerDetails, retryCount + 1, maxRetries);
                        }, delay);

                        return; // Don't show error yet
                    }

                    setSecureSubmitLoading(false);
                    disableSecureOptions(false);
                    hideSecureConfidencePrompt(); // Ensure hidden on error

                    // Save to local storage for manual recovery
                    try {
                        localStorage.setItem('secure_pending_answer', JSON.stringify(answerDetails));
                    } catch (e) {
                        console.error('Failed to backup answer', e);
                    }

                    handleError('Submission failed after ' + (retryCount + 1) + ' attempts. Your answer is backed up. Please check your connection and try again.');
                })
                .submitIndividualTimedAnswer(
                    answerDetails.pollId,
                    answerDetails.sessionId,
                    answerDetails.actualQuestionIndex,
                    answerDetails.answer,
                    SESSION_TOKEN,
                    answerDetails.confidenceLevel
                );
        }

        function stopSecureCountdown() {
            secureCountdownController.stop();
        }

        function applyTimerVisibility() {
            if (!secureCountdownEl || !secureTopbarTimer) return;
            secureCountdownEl.textContent = timerHidden ? '‚Ä¢‚Ä¢:‚Ä¢‚Ä¢' : lastTimerDisplay;
            secureTopbarTimer.classList.toggle('timer-hidden', timerHidden);
            if (timerVisibilityToggle) {
                timerVisibilityToggle.setAttribute('aria-pressed', timerHidden ? 'true' : 'false');
                timerVisibilityToggle.setAttribute('aria-label', timerHidden ? 'Show timer' : 'Hide timer');
                var icon = timerVisibilityToggle.querySelector('.material-symbols-outlined');
                if (icon) {
                    icon.textContent = timerHidden ? 'visibility_off' : 'visibility';
                }
            }
        }

        function updateSecureTimerDisplay(seconds) {
            if (!secureCountdownEl || !secureTopbarTimer) return;
            var safeSeconds = Math.max(0, seconds);
            lastTimerDisplay = formatTime(safeSeconds);
            secureTopbarTimer.classList.remove('alert-warning', 'alert-danger');
            var ratio = secureCountdownTotal > 0 ? Math.max(0, Math.min(1, safeSeconds / secureCountdownTotal)) : 1;
            if (ratio <= 0.1) {
                secureTopbarTimer.classList.add('alert-danger');
            } else if (ratio <= 0.25) {
                secureTopbarTimer.classList.add('alert-warning');
            }
            applyTimerVisibility();
        }

        function startSecureCountdown(timeRemainingSeconds) {
            var remaining = Math.max(0, Math.floor(timeRemainingSeconds || 0));
            secureCountdownTotal = remaining || secureCountdownTotal;
            lastTimerDisplay = formatTime(remaining);
            applyTimerVisibility();
            secureCountdownController.start(remaining);
        }

        function handleSecureTimeExpiry() {
            if (secureTimeExpired) return;
            secureTimeExpired = true;
            showSecureOverlay('TIME_UP', "Time's up!", 'Hold tight while we finalize your work.');
            autoSubmitSecureAnswer(false);
            scheduleSecureWindowClose(4000);
        }

        function showSecureConfidencePrompt(answerText) {
            if (!secureConfidencePrompt) return;

            securePendingAnswerText = answerText;

            // Hide question content, show confidence prompt
            if (secureQuestionText) secureQuestionText.style.display = 'none';
            if (secureQuestionImage) secureQuestionImage.style.display = 'none';
            if (secureOptionsList) secureOptionsList.style.display = 'none';
            if (secureSubmitBtn) secureSubmitBtn.style.display = 'none';

            secureConfidencePrompt.style.display = 'block';
            secureConfidencePrompt.classList.remove('hidden');

            // Attach confidence button handlers
            var confidenceBtns = secureConfidencePrompt.querySelectorAll('.confidence-btn');
            confidenceBtns.forEach(function (btn) {
                btn.onclick = function () {
                    var confidenceLevel = btn.getAttribute('data-confidence');
                    handleSecureConfidenceSelection(confidenceLevel);
                };
            });
        }

        function hideSecureConfidencePrompt() {
            if (!secureConfidencePrompt) return;
            secureConfidencePrompt.style.display = 'none';
            secureConfidencePrompt.classList.add('hidden');

            // Restore question display
            if (secureQuestionText) secureQuestionText.style.display = 'block';
            if (secureOptionsList) secureOptionsList.style.display = 'block';
            if (secureSubmitBtn) secureSubmitBtn.style.display = 'block';
        }

        function handleSecureConfidenceSelection(confidenceLevel) {
            // Allow empty strings (blank answers), only reject null/undefined
            if (securePendingAnswerText == null || !secureQuestionState) return;

            hideSecureConfidencePrompt();

            // Submit answer with confidence
            submitIndividualAnswerWithConfidence(
                secureQuestionState,
                securePendingAnswerText,
                confidenceLevel
            );

            // Clear pending state
            securePendingAnswerText = null;
        }

        function autoSubmitSecureAnswer(forceBlank) {
            if (!secureQuestionState || secureSubmitting) return;
            var answerText = '';
            if (!forceBlank && typeof secureSelectedOptionIndex === 'number') {
                var option = (secureQuestionState.question.options || [])[secureSelectedOptionIndex];
                if (option && typeof option.text === 'string') {
                    answerText = option.text;
                }
            }
            // Pass true for isAutoSubmit to bypass confidence prompt on timeout
            submitIndividualAnswer(secureQuestionState, answerText, true);
        }

        function attemptSecureWindowClose() {
            try {
                if (document && document.fullscreenElement && document.exitFullscreen) {
                    document.exitFullscreen().catch(function (err) {
                        console.warn('Error exiting fullscreen:', err);
                    });
                }
            } catch (err) {
                console.warn('Unable to exit fullscreen', err);
            }
            try {
                if (google && google.script && google.script.host && typeof google.script.host.close === 'function') {
                    google.script.host.close();
                    return;
                }
            } catch (err) {
                console.warn('Unable to close Apps Script host', err);
            }
            if (typeof window !== 'undefined' && typeof window.close === 'function') {
                window.close();
            }
        }

        function clearSecureCloseTimer() {
            if (secureCloseTimer) {
                clearTimeout(secureCloseTimer);
                secureCloseTimer = null;
            }
        }

        function scheduleSecureWindowClose(delayMs) {
            if (secureCloseTimer) return;
            var timeout = Math.max(500, Number(delayMs) || 2500);
            secureCloseTimer = setTimeout(function () {
                secureCloseTimer = null;
                attemptSecureWindowClose();
            }, timeout);
        }

        function exitSecureSessionNow() {
            clearSecureCloseTimer();
            attemptSecureWindowClose();
        }

        function finalizeSecureSession(statusType, message, subtext) {
            stopSecureCountdown();
            setSecureConnectionIndicatorVisible(false);
            if (secureSessionActive) {
                secureSessionHeartbeat.stop();
                secureSessionActive = false;
            }
            setSecureChromeState(false);
            secureQuestionState = null;
            secureCurrentQuestionKey = null;
            secureSelectedOptionIndex = null;
            secureSubmitting = false;
            // Hide calculator when session ends
            if (typeof hideCalculatorOnSessionEnd === 'function') {
                hideCalculatorOnSessionEnd();
            }
            showSecureOverlay(statusType, message, subtext);
            scheduleSecureWindowClose(2500);
        }

        function showSecureOverlay(type, message, subtext) {
            var icon = 'lock';
            var iconClass = 'text-red-300';
            var messageClass = 'text-white text-2xl font-semibold';
            var subClass = 'text-white/80 text-base mt-4';
            var showExitAction = type === 'COMPLETED' || type === 'ENDED';
            var exitLabel = type === 'ENDED' ? 'Exit Session' : 'Exit Secure Session';
            var exitDescription = 'Use the button below to leave fullscreen and close the secure window when dismissed.';
            if (type === 'COMPLETED') {
                icon = 'task_alt';
                iconClass = 'text-green-300';
                messageClass = 'text-green-200 text-2xl font-semibold';
            } else if (type === 'TIME_UP') {
                icon = 'hourglass_bottom';
                showExitAction = false;
            } else if (type === 'ENDED') {
                icon = 'info';
            } else if (type === 'LOCKED') {
                // FIX TASK C: High-contrast styling for lock overlay (no pale pink-on-white)
                icon = 'lock';
                iconClass = 'text-red-600';
                messageClass = 'text-gray-900 text-2xl font-bold';
                subClass = 'text-gray-800 text-base mt-4 whitespace-pre-line';
                showExitAction = false;
            }
            showStatusPanel({
                icon: icon,
                iconClass: iconClass,
                message: message || '',
                messageClass: messageClass,
                subtext: subtext || '',
                subClass: subClass,
                showExitAction: showExitAction,
                exitActionLabel: exitLabel,
                exitActionDescription: exitDescription,
                showResume: false,
                lockScroll: true
            });
        }

        function hideSecureOverlay() {
            if (document && document.body) {
                document.body.classList.remove('secure-overlay-active');
            }
            if (statusContainer && !isInteractionBlocked) {
                statusContainer.style.display = 'none';
            }
            if (statusSubMessage) {
                statusSubMessage.style.display = 'none';
                statusSubMessage.textContent = '';
            }
        }

        function showSecureLockout(message, subtext) {
            stopSecureCountdown();
            setSecureConnectionIndicatorVisible(true);
            if (secureFocusContainer) {
                secureFocusContainer.style.display = 'block';
            }
            disableSecureOptions(true);
            showSecureOverlay('LOCKED', message || 'Assessment Paused', subtext || 'Fullscreen exit detected. Your teacher will re-admit you shortly.');
            // Hide calculator when locked
            if (typeof hideCalculatorOnSessionEnd === 'function') {
                hideCalculatorOnSessionEnd();
            }
        }

        function updateSecureConnectionIndicators(state) {
            if (!state || !secureConnectionDot) return;
            var health = (state.connectionHealth || '').toUpperCase();
            var dotClasses = ['bg-emerald-400', 'bg-amber-400', 'bg-red-500'];
            dotClasses.forEach(function (cls) { secureConnectionDot.classList.remove(cls); });
            var label = 'Synced';
            var warningText = '';
            if (health === 'RED') {
                secureConnectionDot.classList.add('bg-red-500');
                label = 'Connection issue';
                warningText = 'We are reconnecting and saving your work...';
            } else if (health === 'YELLOW') {
                secureConnectionDot.classList.add('bg-amber-400');
                label = 'Reconnecting';
                warningText = 'Syncing your progress...';
            } else {
                secureConnectionDot.classList.add('bg-emerald-400');
                label = 'Synced';
            }
            var lagSeconds = state.heartbeatLagMs ? Math.max(0, Math.round(state.heartbeatLagMs / 1000)) : 0;
            if (secureConnectionStatus) {
                var srLabel = label;
                if (lagSeconds > 0) {
                    srLabel += ' ‚Ä¢ ' + lagSeconds + ' second lag';
                }
                secureConnectionStatus.textContent = srLabel;
            }
            if (secureConnectionWarning) {
                if (warningText) {
                    secureConnectionWarning.textContent = warningText;
                    secureConnectionWarning.classList.remove('hidden');
                } else {
                    secureConnectionWarning.textContent = '';
                    secureConnectionWarning.classList.add('hidden');
                }
            }
        }

        function pollForIndividualSessionState() {
            // POISON PILL CHECK: If lock is active, immediately show lock UI and return
            if (isPoisonPillActive()) {
                console.log('[Proctor] POISON PILL ACTIVE in pollForIndividualSessionState - blocking');
                isInteractionBlocked = true;
                showLockEnforcementUI();
                return;
            }

            if (securePollInFlight) return;
            securePollInFlight = true;
            var telemetry = ActivityMonitor.getInstance().getTelemetry();
            google.script.run
                .withSuccessHandler(function (state) {
                    securePollInFlight = false;
                    if (studentLoader) {
                        studentLoader.style.display = 'none';
                    }
                    if (!state) {
                        return;
                    }
                    if (state.status === 'LOBBY') {
                        showSecureLobby(state);
                        return;
                    }
                    if (state.sessionType === 'INDIVIDUAL_TIMED' || state.sessionType === 'SECURE_ASSESSMENT') {
                        hideSecureLobby();
                        var lockReason = (state.lockReason || '').toString().toUpperCase();
                        var lockMessage = (state.message || '').toString().toLowerCase();
                        var isTerminalLock = state.locked === true || lockReason === 'FORCED_SUBMIT' || lockReason === 'TIME_EXPIRED' || lockMessage.indexOf('ended') >= 0 || lockMessage.indexOf('submitted') >= 0;
                        if (state.completed || state.status === 'COMPLETED') {
                            updateSecureConnectionIndicators(state);
                            finalizeSecureSession('COMPLETED', state.message || 'Transmission Complete', 'Your responses have been secured. Use the exit button below when dismissed.');
                        } else if (state.status === 'ENDED') {
                            updateSecureConnectionIndicators(state);
                            finalizeSecureSession('ENDED', state.message || 'Session Concluded', 'Use the exit button below to leave the secure environment.');
                        } else if (isTerminalLock) {
                            updateSecureConnectionIndicators(state);
                            finalizeSecureSession('ENDED', state.message || 'Assessment Finalized', 'Your responses have been secured. You may now exit.');
                        } else if (state.status === 'LOCKED') {
                            if (secureFocusContainer) secureFocusContainer.style.display = 'block';
                            secureQuestionState = null;
                            secureCurrentQuestionKey = null;
                            secureSelectedOptionIndex = null;
                            updateSecureConnectionIndicators(state);
                            showSecureLockout(state.message || 'Assessment Paused', 'Your teacher will grant re-entry shortly.');
                        } else if (isInteractionBlocked) {
                            updateSecureConnectionIndicators(state);
                            setSecureConnectionIndicatorVisible(true);
                            showSecureLockout(state.message || 'Assessment Paused', 'Your teacher will grant re-entry shortly.');
                        } else if (state.question && (state.status === 'ACTIVE' || !state.status)) {
                            showIndividualTimedView(state);
                        } else {
                            console.log('Secure session state', state);
                        }
                    } else {
                        updateStudentView(state);
                    }
                })
                .withFailureHandler(function (error) {
                    securePollInFlight = false;
                    handleError(error);
                })
                .getIndividualTimedSessionState(SESSION_TOKEN, telemetry);
        }

        if (secureSubmitBtn) {
            secureSubmitBtn.addEventListener('click', function () {
                if (!secureQuestionState || secureSubmitting) return;
                var answerText = '';
                if (typeof secureSelectedOptionIndex === 'number') {
                    var option = (secureQuestionState.question.options || [])[secureSelectedOptionIndex];
                    if (option && typeof option.text === 'string') {
                        answerText = option.text;
                    }
                }
                submitIndividualAnswer(secureQuestionState, answerText);
            });
        }

        // Add click handler to secure assessment question image for zoom
        if (secureQuestionImage) {
            secureQuestionImage.addEventListener('click', function (e) {
                e.stopPropagation();
                e.preventDefault();
                if (window.expandImage) {
                    window.expandImage(this);
                }
            });
        }

        console.log('Student poll script initializing...');

        // Check for pending answer backup on initialization
        try {
            var backup = localStorage.getItem('secure_pending_answer');
            if (backup) {
                var answerDetails = JSON.parse(backup);
                // Use a slight delay to ensure UI is ready
                setTimeout(function () {
                    if (confirm('Veritas found an unsaved answer from a previous session. Would you like to retry submitting it?')) {
                        // Create a dummy state to pass to submit
                        var dummyState = {
                            pollId: answerDetails.pollId,
                            sessionId: answerDetails.sessionId,
                            actualQuestionIndex: answerDetails.actualQuestionIndex,
                            question: {} // Dummy question object
                        };

                        // Manually trigger submission with recovered data
                        submitIndividualAnswerWithConfidence(
                            dummyState,
                            answerDetails.answer,
                            answerDetails.confidenceLevel
                        );
                    } else {
                        localStorage.removeItem('secure_pending_answer');
                    }
                }, 1000);
            }
        } catch (e) {
            console.error('Failed to check backup', e);
        }

        var studentLoader = document.getElementById('student-loader');
        var preLiveCard = document.getElementById('pre-live-card');
        var statusContainer = document.getElementById('status-container');
        var statusMessage = document.getElementById('status-message');
        var questionContainer = document.getElementById('question-container');
        var optionsList = document.getElementById('options-list');
        var questionTextEl = document.getElementById('question-text');
        var questionImageEl = document.getElementById('question-image');
        var questionSublineEl = document.getElementById('question-subline');
        var noResponsesMessageEl = document.getElementById('no-responses-message');
        var entryScreen = document.getElementById('entry-screen');
        var startSessionBtn = document.getElementById('start-session-btn');
        var studentContainer = document.getElementById('student-container');
        // Simple image zoom function (same approach as teacher panel)
        window.expandImage = function (imgElement) {
            var imgSrc = imgElement.src;
            var modalHtml = '<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:9999;display:flex;align-items:center;justify-content:center;cursor:pointer;" onclick="this.remove()">';
            modalHtml += '<img src="' + imgSrc + '" style="max-width:90%;max-height:90%;"/>';
            modalHtml += '</div>';
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        };

        // Add click handler to question image
        if (questionImageEl) {
            questionImageEl.addEventListener('click', function (e) {
                e.stopPropagation();
                e.preventDefault();
                window.expandImage(this);
            });
        }

        // Event delegation for dynamically created option images
        document.addEventListener('click', function (e) {
            if (e.target.classList.contains('option-image')) {
                e.stopPropagation();
                e.preventDefault();
                window.expandImage(e.target);
            }
        });
        var preLivePrimary = document.getElementById('pre-live-primary');
        var preLiveSubline = document.getElementById('pre-live-subline');
        var preLiveReconnectLine = document.getElementById('pre-live-reconnect-line');

        console.log('Start session button found:', startSessionBtn ? 'YES' : 'NO');
        console.log('Entry screen found:', entryScreen ? 'YES' : 'NO');
        var resumeControls = document.getElementById('resume-controls');
        var resumeSessionBtn = document.getElementById('resume-session-btn');
        var secureExitControls = document.getElementById('secure-exit-controls');
        var secureExitDescription = document.getElementById('secure-exit-description');
        var secureExitButton = document.getElementById('secure-exit-btn');
        var secureExitLabel = document.getElementById('secure-exit-label');
        var statusSubMessage = document.getElementById('status-submessage');
        var connectivityBanner = document.getElementById('connectivity-banner');
        var connectivityIcon = document.getElementById('connectivity-icon');
        var connectivityMessage = document.getElementById('connectivity-message');
        var connectivitySubMessage = document.getElementById('connectivity-submessage');

        var currentPollState = {};
        var lastUnlockedState = null;
        var pollTimerId = null;
        var defaultPollInterval = 2500;
        var maxPollInterval = 12000;
        var pollFailureCount = 0;
        var proctorPollInterval = null;
        var isInteractionBlocked = false;
        var isTeacherBlocked = false;
        var currentLockVersion = 0;
        var hasAnsweredCurrent = false;
        var violationLogged = false;
        var violationDebounceTimer = null;
        var fullscreenEnteredOnce = false; // Track if fullscreen has been entered to prevent false violations
        var pendingSubmission = false;
        var currentQuestionKey = null;
        var pendingAnswerText = null; // Store answer while waiting for confidence
        var currentMetacognitionEnabled = false; // Track if current question has metacognition
        var lastStateVersion = null;
        var lastSuccessfulPollAt = 0;
        var pollInFlight = false;
        var recoveringFromOutage = false;
        var connectivityHideTimer = null;
        var lastAdvisedInterval = defaultPollInterval;

        // --- PROCTORING SAFEGUARDS ---
        var secureSessionActive = false; // Must be TRUE for lock logic to engage
        var isEnteringFullscreen = false; // Grace period flag
        // -----------------------------

        var optionBaseClass = 'answer-option relative w-full text-left';
        var optionSelectedClass = optionBaseClass + ' answer-option-selected';
        var optionDisabledClass = optionBaseClass + ' answer-option-disabled';
        var SECURE_RULES_FALLBACK = [
            'Stay in fullscreen for the entire assessment',
            'No tab or app switching is allowed',
            'Mission Control monitors your progress in real time'
        ];
        var secureLobbyCard = document.getElementById('secure-lobby');
        var secureLobbyTitle = document.getElementById('secure-lobby-title');
        var secureLobbySummary = document.getElementById('secure-lobby-summary');
        var secureLobbyTime = document.getElementById('secure-lobby-time');
        var secureLobbyQuestions = document.getElementById('secure-lobby-questions');
        var secureWindowMessage = document.getElementById('secure-window-message');
        var secureAccessCodeGroup = document.getElementById('secure-access-code-group');
        var secureAccessCodeInput = document.getElementById('secure-access-code');
        var secureAccessCodeError = document.getElementById('secure-access-code-error');
        var secureBeginBtn = document.getElementById('secure-begin-btn');
        var secureBeginLabel = document.getElementById('secure-begin-label');
        var secureRulesList = document.getElementById('secure-rules-list');
        var secureLobbyContext = null;
        var secureWindowAutoReloaded = false;
        var blurListenerAttached = false;
        var liveSessionActive = false;

        function handleViolation(reason) {
            try {
                sessionStorage.setItem('veritas_lock_active', 'true');
                sessionStorage.setItem('lock_reason', reason || 'violation');
            } catch (e) { }
            LockManager.lock(reason || 'proctoring_violation');
            if (typeof reportViolationDebounced === 'function') {
                reportViolationDebounced(reason);
            }
        }

        function triggerSecurityViolation(reason) {
            handleViolation(reason);
        }

        /**
         * UNIFIED PROCTORING HANDLER
         * Handles blur, fullscreen exit, and tab switching.
         * Flow: 1. Check Calculator (Safe Harbor) -> 2. Set Lock Flag -> 3. Report Violation -> 4. Show Lock UI
         */
        function handlePotentialViolation(reason) {
            // 1. SAFE HARBOR CHECK (Critical)
            // If the student is clicking inside the TI-84 Calculator iframe,
            // the window 'blurs', but this is NOT a violation. Return immediately.
            if (document.activeElement && document.activeElement.id === 'calc-iframe') {
                return;
            }

            // 2. THE LOCK (Poison Pill)
            // Persist the lock state so a refresh won't fix it.
            sessionStorage.setItem('veritas_lock_active', 'true');

            // 3. THE REPORT
            // Send telemetry to the server (if ID exists)
            if (typeof reportViolation === 'function') {
                reportViolation(reason);
            } else if (typeof reportViolationDebounced === 'function') {
                reportViolationDebounced(reason);
            }

            // 4. SHOW LOCK UI
            showLockEnforcementUI(reason);
        }

        // ROBUST VIOLATION REPORTING WITH FAILSAFE POLL ID LOOKUP
        function reportViolation(reason) {
            // ROBUST ID CHECK: Check Global -> Data Object -> Storage
            var pid = window.currentPollId ||
                (window.pollData && window.pollData.pollId) ||
                sessionStorage.getItem('veritas_active_poll_id');

            if (!pid) {
                console.error('[Proctor] CRITICAL: Attempted to report violation but Poll ID is missing. Retrying in 1s...');
                // Retry once if ID is missing (race condition fix)
                setTimeout(function () { reportViolation(reason); }, 1000);
                return;
            }

            console.warn('[Proctor] Reporting violation:', reason, 'for Poll:', pid);

            // FIREBASE: Instant Lock (Fail-safe)
            try {
                if (typeof reportFirebaseViolation === 'function') {
                    reportFirebaseViolation(reason, pid);
                }
            } catch (e) {
                console.warn('[Proctor] Firebase reporting failed:', e);
            }

            // CRITICAL FIX: Get fallback email for robust student identification
            var fallbackEmail = window.STUDENT_EMAIL || '';
            if (!fallbackEmail) {
                try { fallbackEmail = sessionStorage.getItem('veritas_student_email') || ''; } catch (e) { }
            }

            // FIX: Use the correct API with token - logStudentViolation was broken (ignored params)
            google.script.run
                .withSuccessHandler(function (response) {
                    console.log('[Proctor] Violation logged, server response:', response);
                    if (response && response.lockVersion !== undefined) {
                        currentLockVersion = response.lockVersion;
                    }
                })
                .withFailureHandler(function (error) {
                    console.error('[Proctor] Violation report failed:', error);
                })
                .reportStudentViolation(pid, SESSION_TOKEN, reason, fallbackEmail);
        }

        function reportViolationDebounced(reason) {
            // FIX: Immediately block interaction to prevent submissions during debounce
            if (!isInteractionBlocked && !violationLogged && secureSessionActive) {
                console.log('[Proctor] Violation detected:', reason, '- blocking interaction immediately');
                isInteractionBlocked = true;
                showLockEnforcementUI();

                // FIREBASE: Instant Lock
                reportFirebaseViolation(reason);
            }

            if (violationDebounceTimer) {
                clearTimeout(violationDebounceTimer);
            }
            // FIX: Reduce debounce from 300ms to 100ms for faster blocking
            violationDebounceTimer = setTimeout(function () {
                if (violationLogged) {
                    return;
                }

                // ROBUST POLL ID RESOLUTION: Check all sources to avoid silent failures
                var activePollId = (currentPollState && currentPollState.pollId) ||
                    (secureLobbyContext && secureLobbyContext.pollId) ||
                    window.currentPollId;

                // FALLBACK: Check sessionStorage if all in-memory sources failed
                if (!activePollId) {
                    try {
                        activePollId = sessionStorage.getItem('veritas_active_poll_id');
                    } catch (e) { /* Storage may be unavailable */ }
                }

                if (!activePollId) {
                    console.error('[Proctor] CRITICAL: Cannot report violation - no poll ID found in any source');
                    // Still show lock UI even without server report
                    showLockEnforcementUI();
                    return;
                }

                violationLogged = true;
                isInteractionBlocked = true;
                console.log('[Proctor] Reporting violation to server:', reason, 'pollId:', activePollId);

                // FIREBASE: Ensure locked state is set with pollId for teacher visibility
                reportFirebaseViolation(reason, activePollId);

                // CRITICAL FIX: Get fallback email for robust student identification
                var fallbackEmail = window.STUDENT_EMAIL || '';
                if (!fallbackEmail) {
                    try { fallbackEmail = sessionStorage.getItem('veritas_student_email') || ''; } catch (e) { }
                }

                showLockEnforcementUI();
                google.script.run
                    .withSuccessHandler(function (response) {
                        console.log('[Proctor] Violation reported, server response:', response);
                        if (response.success) {
                            currentLockVersion = response.lockVersion;
                            showLockEnforcementUI();
                            startProctorPolling();
                        }
                    })
                    .withFailureHandler(function (error) {
                        console.error('[Proctor] Violation report failed:', error);
                        showLockEnforcementUI();
                    })
                    .reportStudentViolation(activePollId, SESSION_TOKEN, reason, fallbackEmail);
            }, 100);
        }

        function attachProctorVisibilityListeners() {
            if (blurListenerAttached) { return; }
            blurListenerAttached = true;

            // ZERO TOLERANCE: Immediate lock on window blur
            window.addEventListener('blur', function () {
                // 1. GLOBAL SAFEGUARDS
                if (!secureSessionActive || isEnteringFullscreen || isInteractionBlocked || isTeacherBlocked) return;

                violationLogged = true;
                handlePotentialViolation('tab_switch');
            });

            // ZERO TOLERANCE: Immediate lock on tab visibility change
            document.addEventListener('visibilitychange', function () {
                if (document.hidden) {
                    if (!secureSessionActive || isEnteringFullscreen || isInteractionBlocked || isTeacherBlocked) return;
                    violationLogged = true;
                    handlePotentialViolation('tab_hidden');
                }
            });
        }

        var VeritasModal = null;
        var veritasModalReady = new Promise(function (resolve) {
            function initializeModal() {
                VeritasModal = window.VeritasModal || createVeritasModal();
                window.VeritasModal = VeritasModal;
                resolve(VeritasModal);
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeModal, { once: true });
            } else {
                initializeModal();
            }
        });

        function withVeritasModal(callback) {
            return veritasModalReady.then(function (controller) {
                return callback(controller);
            });
        }

        function veritasAlert(message, options) {
            return withVeritasModal(function (modal) {
                return modal.alert(Object.assign({ message: message }, options || {}));
            });
        }

        function veritasConfirm(message, options) {
            return withVeritasModal(function (modal) {
                return modal.confirm(Object.assign({ message: message }, options || {}));
            });
        }

        function veritasPrompt(message, options) {
            return withVeritasModal(function (modal) {
                return modal.prompt(Object.assign({ message: message }, options || {}));
            });
        }

        function describeSecureTimeLimit(minutes) {
            if (!minutes || minutes <= 0) {
                return 'Untimed';
            }
            if (minutes >= 60) {
                var hours = Math.floor(minutes / 60);
                var remainder = minutes % 60;
                if (remainder === 0) {
                    return hours + (hours === 1 ? ' hour' : ' hours');
                }
                return hours + ' hr ' + remainder + ' min';
            }
            return minutes + ' min';
        }

        function describeSecureQuestionCount(count) {
            if (typeof count !== 'number' || count <= 0) {
                return '‚Äî';
            }
            return count + (count === 1 ? ' Question' : ' Questions');
        }

        function renderSecureRules(rules) {
            if (!secureRulesList) return;
            secureRulesList.innerHTML = '';
            var appliedRules = Array.isArray(rules) && rules.length ? rules : SECURE_RULES_FALLBACK;
            appliedRules.forEach(function (rule) {
                var li = document.createElement('li');
                var icon = document.createElement('span');
                icon.className = 'material-symbols-outlined text-base text-veritas-navy mt-0.5';
                icon.textContent = 'shield_person';
                var text = document.createElement('span');
                text.textContent = rule;
                li.appendChild(icon);
                li.appendChild(text);
                secureRulesList.appendChild(li);
            });
        }

        function setSecureAccessError(message) {
            if (!secureAccessCodeError) return;
            if (message) {
                secureAccessCodeError.textContent = message;
                secureAccessCodeError.classList.remove('hidden');
            } else {
                secureAccessCodeError.textContent = '';
                secureAccessCodeError.classList.add('hidden');
            }
        }

        function computeSecureBeginLabel(windowStatus) {
            if (windowStatus === 'NOT_YET_OPEN') {
                return 'Opens Soon';
            }
            if (windowStatus === 'PAST_DUE') {
                return 'Window Closed';
            }
            return 'Begin Assessment';
        }

        function isSecureWindowBlocked(status) {
            return status === 'NOT_YET_OPEN' || status === 'PAST_DUE';
        }

        function updateSecureBeginButton() {
            if (!secureBeginBtn) return;
            var windowStatus = secureLobbyContext ? secureLobbyContext.windowStatus : 'OPEN';
            var label = computeSecureBeginLabel(windowStatus);
            var blocked = isSecureWindowBlocked(windowStatus);
            var loading = secureBeginBtn.dataset.loading === '1';
            if (secureLobbyContext) {
                secureLobbyContext.beginLabel = label;
            }
            secureBeginBtn.disabled = blocked || loading;
            secureBeginBtn.classList.toggle('opacity-60', blocked || loading);
            if (secureBeginLabel && !loading) {
                secureBeginLabel.textContent = label;
            }
        }

        function setSecureBeginLoading(isLoading) {
            if (!secureBeginBtn) return;
            secureBeginBtn.dataset.loading = isLoading ? '1' : '0';
            if (isLoading) {
                secureBeginBtn.disabled = true;
                secureBeginBtn.classList.add('opacity-60');
                if (secureBeginLabel) {
                    secureBeginLabel.textContent = 'Preparing...';
                }
            } else {
                secureBeginBtn.classList.remove('opacity-60');
                updateSecureBeginButton();
            }
        }

        function hideSecureLobby() {
            if (secureLobbyCard) {
                secureLobbyCard.style.display = 'none';
            }
            secureLobbyContext = null;
            setSecureAccessError('');
        }

        function shouldAutoReloadForSecureWindow(previousStatus, nextStatus) {
            if (!previousStatus || !nextStatus) {
                return false;
            }
            var wasBlocked = isSecureWindowBlocked(previousStatus);
            var isBlockedNow = isSecureWindowBlocked(nextStatus);
            return wasBlocked && !isBlockedNow;
        }

        function triggerSecureWindowReload() {
            if (secureWindowAutoReloaded) {
                return;
            }
            secureWindowAutoReloaded = true;
            if (secureBeginBtn) {
                secureBeginBtn.disabled = true;
                secureBeginBtn.classList.add('opacity-60');
            }
            if (secureBeginLabel) {
                secureBeginLabel.textContent = 'Refreshing...';
            }
            setTimeout(function () {
                window.location.reload();
            }, 750);
        }

        function showSecureLobby(state) {
            var previousContext = secureLobbyContext;
            var previousLobbyKey = previousContext && previousContext.lobbyKey
                ? previousContext.lobbyKey
                : (previousContext ? (previousContext.pollId + '|' + previousContext.sessionId) : null);
            var nextLobbyKey = (state.pollId || 'poll') + '|' + (state.sessionId || '');
            var isNewLobbyContext = previousLobbyKey !== nextLobbyKey;
            var previousWindowStatus = previousContext ? previousContext.windowStatus : null;
            setSecureConnectionIndicatorVisible(false);
            setSecureChromeState(true);

            secureLobbyContext = {
                pollId: state.pollId,
                sessionId: state.sessionId,
                requiresAccessCode: !!state.requiresAccessCode,
                windowStatus: (state.availability && state.availability.windowStatus) || state.windowStatus || 'OPEN',
                lobbyKey: nextLobbyKey
            };

            // CRITICAL: Persist pollId for violation reporting (secure session path)
            if (state.pollId) {
                window.currentPollId = state.pollId;
                try {
                    sessionStorage.setItem('veritas_active_poll_id', state.pollId);
                } catch (e) { /* Storage may be unavailable */ }
            }

            if (shouldAutoReloadForSecureWindow(previousWindowStatus, secureLobbyContext.windowStatus)) {
                triggerSecureWindowReload();
                return;
            }

            if (entryScreen) entryScreen.style.display = 'none';
            if (studentContainer) studentContainer.style.display = 'block';
            if (studentLoader) studentLoader.style.display = 'none';
            if (preLiveCard) preLiveCard.style.display = 'none';
            if (statusContainer) statusContainer.style.display = 'none';
            if (questionContainer) questionContainer.style.display = 'none';
            // Explicitly hide secure assessment canvas until we begin
            if (secureFocusContainer) secureFocusContainer.style.display = 'none';
            toggleSecureLayout(false);
            if (questionProgressEl) {
                questionProgressEl.textContent = 'STANDBY';
            }
            if (secureLobbyCard) secureLobbyCard.style.display = 'block';

            if (secureLobbyTitle) {
                secureLobbyTitle.textContent = state.pollName || 'Secure Assessment';
            }
            if (secureLobbySummary) {
                if (state.className) {
                    secureLobbySummary.textContent = 'Class: ' + state.className;
                    secureLobbySummary.style.display = 'block';
                    secureLobbySummary.classList.remove('hidden');
                } else {
                    secureLobbySummary.textContent = '';
                    secureLobbySummary.style.display = 'none';
                    secureLobbySummary.classList.add('hidden');
                }
            }
            if (secureLobbyTime) {
                secureLobbyTime.textContent = describeSecureTimeLimit(state.timeLimitMinutes);
            }
            if (secureLobbyQuestions) {
                secureLobbyQuestions.textContent = describeSecureQuestionCount(state.questionCount);
            }

            var availability = state.availability || {};
            var availabilityMessage = availability.message || 'Available now';
            if (availability.blockingMessage) {
                availabilityMessage += ' ‚Ä¢ ' + availability.blockingMessage;
            }
            if (secureWindowMessage) {
                secureWindowMessage.textContent = availabilityMessage;
            }

            if (secureAccessCodeGroup) {
                secureAccessCodeGroup.style.display = secureLobbyContext.requiresAccessCode ? 'block' : 'none';
                secureAccessCodeGroup.classList.toggle('hidden', !secureLobbyContext.requiresAccessCode);
            }
            if (secureAccessCodeInput && isNewLobbyContext) {
                secureAccessCodeInput.value = '';
            }
            if (isNewLobbyContext) {
                setSecureAccessError('');
            }
            renderSecureRules(state.proctoringRules);
            updateSecureBeginButton();
        }

        function requestFullscreenForSecureAssessment() {
            if (!secureFullscreenManager) {
                return Promise.resolve();
            }
            if (secureFullscreenManager.isFullscreen()) {
                return Promise.resolve();
            }
            return secureFullscreenManager.request().catch(function () {
                return Promise.resolve();
            });
        }

        function handleSecureFullscreenChange(event) {
            // ZERO TOLERANCE PROCTORING - Active for ALL sessions (live polls and secure assessments)
            console.log('[Proctor] Fullscreen change event:', {
                isFullscreen: event.isFullscreen,
                hidden: event.hidden,
                secureSessionActive: secureSessionActive,
                liveSessionActive: liveSessionActive,
                fullscreenEnteredOnce: fullscreenEnteredOnce,
                isInteractionBlocked: isInteractionBlocked,
                violationLogged: violationLogged
            });

            // Check for tab blur/switch (visibility hidden) - IMMEDIATE LOCK
            if (event.hidden && !isInteractionBlocked && !violationLogged) {
                console.log('[Proctor] ZERO TOLERANCE: Tab blur detected - IMMEDIATE LOCK');
                triggerSecurityViolation('tab-blur');
                return;
            }

            // Check for entering fullscreen
            if (event.isFullscreen) {
                console.log('[Proctor] Fullscreen entered');
                fullscreenEnteredOnce = true;
                return;
            }

            // Check for exiting fullscreen after having entered - IMMEDIATE LOCK
            // No grace periods. No warnings. Zero tolerance.
            if ((fullscreenEnteredOnce || secureSessionActive || liveSessionActive) && !isInteractionBlocked && !violationLogged) {
                console.log('[Proctor] ZERO TOLERANCE: Fullscreen exit detected - IMMEDIATE LOCK');
                triggerSecurityViolation('exit-fullscreen');
            }
        }

        function handleSecureBeginClick() {
            if (!secureLobbyContext || !secureBeginBtn || secureBeginBtn.disabled) {
                return;
            }
            setSecureAccessError('');
            var providedCode = secureAccessCodeInput ? secureAccessCodeInput.value.trim() : '';
            if (secureLobbyContext.requiresAccessCode && !providedCode) {
                setSecureAccessError('Access code is required.');
                if (secureAccessCodeInput) {
                    secureAccessCodeInput.focus();
                }
                return;
            }

            requestFullscreenForSecureAssessment()
                .then(function () {
                    setSecureBeginLoading(true);
                    isEnteringFullscreen = true; // START GRACE PERIOD

                    // Allow 3 seconds for browser transition chaos to settle
                    setTimeout(function () { isEnteringFullscreen = false; }, 3000);

                    // Double check fullscreen state
                    if (!secureFullscreenManager.isFullscreen()) {
                        throw new Error('Fullscreen failed');
                    }

                    // Immediately mark as active to allow polling, but grace period protects against blur
                    secureSessionActive = true;

                    google.script.run
                        .withSuccessHandler(function (response) {
                            setSecureBeginLoading(false);
                            if (response.success) {
                                // Success!
                                hideAllViews();
                                entryScreen.style.display = 'none';
                                secureLobbyContext = null;
                                veritasToast('Secure Session Started', 'good');

                                // Start polling with active session flag
                                startPolling(true);
                            } else {
                                isEnteringFullscreen = false;
                                secureSessionActive = false;
                                veritasAlert(response.error || 'Failed to start session.', { title: 'Error' });
                            }
                        })
                        .withFailureHandler(function (error) {
                            setSecureBeginLoading(false);
                            isEnteringFullscreen = false;
                            secureSessionActive = false;
                            var message = (error && error.message) ? error.message : 'Unable to begin assessment.';
                            if (/access code/i.test(message)) {
                                setSecureAccessError(message);
                                if (secureAccessCodeInput) {
                                    secureAccessCodeInput.focus();
                                }
                            } else {
                                veritasAlert(message, { title: 'Secure Assessment' });
                            }
                        })
                        .beginIndividualTimedAttempt(
                            secureLobbyContext.pollId,
                            secureLobbyContext.sessionId,
                            SESSION_TOKEN,
                            { accessCode: providedCode }
                        );
                })
                .catch(function (err) {
                    console.warn('Fullscreen request was rejected', err);
                    veritasAlert('Fullscreen permission is required to begin the assessment.', { title: 'Secure Assessment' });
                });
        }

        function ensureVeritasModalRoot() {
            var existing = document.getElementById('veritas-modal-root');
            if (existing) {
                return existing;
            }

            var root = document.createElement('div');
            root.id = 'veritas-modal-root';
            root.className = 'veritas-modal-root';
            root.setAttribute('aria-hidden', 'true');
            root.innerHTML = '' +
                '<div class="veritas-modal-backdrop"></div>' +
                '<div class="veritas-modal-dialog" role="dialog" aria-modal="true" aria-labelledby="veritas-modal-title" aria-describedby="veritas-modal-message">' +
                '<div class="veritas-modal-header">' +
                '<h2 id="veritas-modal-title">Notice</h2>' +
                '</div>' +
                '<div class="veritas-modal-body">' +
                '<p id="veritas-modal-message"></p>' +
                '<div id="veritas-modal-subtext" class="veritas-modal-subtext"></div>' +
                '<div id="veritas-modal-input" class="veritas-modal-input" style="display: none;">' +
                '<label for="veritas-modal-input-field" class="sr-only">Input</label>' +
                '<input id="veritas-modal-input-field" type="text" autocomplete="off" />' +
                '</div>' +
                '<div class="veritas-modal-actions">' +
                '<button type="button" class="veritas-modal-button secondary" data-action="cancel">Cancel</button>' +
                '<button type="button" class="veritas-modal-button primary" data-action="confirm">' +
                '<span class="veritas-modal-spinner" aria-hidden="true"></span>' +
                '<span>Confirm</span>' +
                '</button>' +
                '</div>' +
                '</div>';

            (document.body || document.documentElement).appendChild(root);
            return root;
        }

        function createVeritasModal() {
            var root = ensureVeritasModalRoot();

            var dialog = root.querySelector('.veritas-modal-dialog');
            var titleEl = root.querySelector('#veritas-modal-title');
            var messageEl = root.querySelector('#veritas-modal-message');
            var subtextEl = root.querySelector('#veritas-modal-subtext');
            var inputWrap = root.querySelector('#veritas-modal-input');
            var inputField = root.querySelector('#veritas-modal-input-field');
            var confirmBtn = root.querySelector('[data-action="confirm"]');
            var cancelBtn = root.querySelector('[data-action="cancel"]');
            var confirmLabel = confirmBtn.querySelector('span:not(.veritas-modal-spinner)');
            var active = false;
            var currentConfig = null;
            var resolveFn = null;
            var previousFocus = null;
            var allowEscape = true;
            var hiddenNodes = [];

            function toggleBackground(state) {
                var siblings = [].slice.call(document.body.children);
                if (state) {
                    hiddenNodes = [];
                    siblings.forEach(function (node) {
                        if (node === root) return;
                        hiddenNodes.push({
                            node: node,
                            ariaHidden: node.getAttribute('aria-hidden'),
                            inert: ('inert' in node) ? node.inert : null
                        });
                        node.setAttribute('aria-hidden', 'true');
                        if ('inert' in node) {
                            node.inert = true;
                        }
                    });
                } else {
                    hiddenNodes.forEach(function (record) {
                        if (record.ariaHidden === null) {
                            record.node.removeAttribute('aria-hidden');
                        } else {
                            record.node.setAttribute('aria-hidden', record.ariaHidden);
                        }
                        if ('inert' in record.node) {
                            if (record.inert !== null) {
                                record.node.inert = record.inert;
                            } else {
                                record.node.inert = false;
                            }
                        }
                    });
                    hiddenNodes = [];
                }
            }

            function setPending(state) {
                if (state) {
                    confirmBtn.classList.add('loading');
                    confirmBtn.setAttribute('disabled', 'disabled');
                    if (cancelBtn.style.display !== 'none') {
                        cancelBtn.setAttribute('disabled', 'disabled');
                    }
                } else {
                    confirmBtn.classList.remove('loading');
                    confirmBtn.removeAttribute('disabled');
                    cancelBtn.removeAttribute('disabled');
                }
            }

            function getFocusable() {
                var selectors = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
                var nodes = [].slice.call(dialog.querySelectorAll(selectors));
                return nodes.filter(function (node) {
                    return !node.hasAttribute('disabled') && node.offsetParent !== null;
                });
            }

            function focusFirst() {
                var focusable = getFocusable();
                if (focusable.length > 0) {
                    focusable[0].focus();
                } else {
                    dialog.focus();
                }
            }

            function trapKey(event) {
                if (!active) return;
                if (event.key === 'Escape') {
                    if (!allowEscape) return;
                    event.preventDefault();
                    handleCancel();
                } else if (event.key === 'Tab') {
                    var focusable = getFocusable();
                    if (focusable.length === 0) {
                        event.preventDefault();
                        return;
                    }
                    var index = focusable.indexOf(document.activeElement);
                    if (event.shiftKey) {
                        if (index <= 0) {
                            focusable[focusable.length - 1].focus();
                            event.preventDefault();
                        }
                    } else {
                        if (index === focusable.length - 1) {
                            focusable[0].focus();
                            event.preventDefault();
                        }
                    }
                } else if (event.key === 'Enter' && currentConfig && currentConfig.mode === 'prompt') {
                    if (document.activeElement === inputField) {
                        event.preventDefault();
                        handleConfirm();
                    }
                }
            }

            function enforceFocus(event) {
                if (!active) return;
                if (!dialog.contains(event.target)) {
                    event.stopPropagation();
                    focusFirst();
                }
            }

            function closeModal(result) {
                active = false;
                root.classList.remove('is-active');
                root.setAttribute('aria-hidden', 'true');
                document.body.classList.remove('veritas-modal-open');
                root.removeEventListener('keydown', trapKey, true);
                document.removeEventListener('focus', enforceFocus, true);
                toggleBackground(false);
                setPending(false);
                if (previousFocus && typeof previousFocus.focus === 'function') {
                    setTimeout(function () { previousFocus.focus(); }, 0);
                }
                if (resolveFn) {
                    resolveFn(result);
                }
                currentConfig = null;
                resolveFn = null;
            }

            function handleConfirm() {
                if (!active) return;
                setPending(true);
                var mode = currentConfig ? currentConfig.mode : 'alert';
                var result;
                if (mode === 'prompt') {
                    result = inputField.value;
                } else if (mode === 'confirm') {
                    result = true;
                }
                closeModal(result);
            }

            function handleCancel() {
                if (!active) return;
                var mode = currentConfig ? currentConfig.mode : 'alert';
                if (mode === 'alert') {
                    closeModal(undefined);
                    return;
                }
                if (mode === 'confirm') {
                    closeModal(false);
                } else if (mode === 'prompt') {
                    closeModal(null);
                }
            }

            function openModal(mode, options) {
                options = options || {};
                currentConfig = Object.assign({}, options, { mode: mode });
                allowEscape = options.allowEscape !== false;
                titleEl.textContent = options.title || (mode === 'confirm' ? 'Please Confirm' : (mode === 'prompt' ? 'Enter Response' : 'Notice'));

                // SECURITY DOCUMENTATION: Trust Boundary for options.html
                // The options.html parameter accepts raw HTML and uses innerHTML (XSS risk).
                // This is INTERNAL-ONLY and must NEVER receive user-controlled data.
                // All callers of openModal() in this codebase use app-controlled strings only.
                // If adding new calls with dynamic content, use options.message (textContent) instead,
                // or sanitize user data with escapeHtml() before passing to options.html.
                if (options.html) {
                    messageEl.innerHTML = options.html;  // INTERNAL ONLY - never pass user data
                } else {
                    messageEl.textContent = options.message || '';
                }
                if (options.subtext) {
                    subtextEl.style.display = 'block';
                    subtextEl.textContent = options.subtext;
                } else {
                    subtextEl.style.display = 'none';
                    subtextEl.textContent = '';
                }
                if (mode === 'prompt') {
                    inputWrap.style.display = 'flex';
                    inputField.value = options.defaultValue || '';
                    if (options.placeholder) {
                        inputField.placeholder = options.placeholder;
                    } else {
                        inputField.removeAttribute('placeholder');
                    }
                } else {
                    inputWrap.style.display = 'none';
                    inputField.value = '';
                    inputField.removeAttribute('placeholder');
                }
                confirmLabel.textContent = options.confirmText || (mode === 'confirm' ? 'Confirm' : (mode === 'prompt' ? 'Submit' : 'OK'));
                if (options.destructive) {
                    confirmBtn.classList.add('destructive');
                } else {
                    confirmBtn.classList.remove('destructive');
                }
                cancelBtn.style.display = mode === 'alert' ? 'none' : 'inline-flex';
                cancelBtn.textContent = options.cancelText || 'Cancel';
                setPending(false);
                previousFocus = document.activeElement;
                root.classList.add('is-active');
                root.setAttribute('aria-hidden', 'false');
                document.body.classList.add('veritas-modal-open');
                toggleBackground(true);
                active = true;
                root.addEventListener('keydown', trapKey, true);
                document.addEventListener('focus', enforceFocus, true);

                return new Promise(function (resolve) {
                    resolveFn = resolve;
                    setTimeout(function () {
                        if (mode === 'prompt') {
                            inputField.focus();
                            inputField.select();
                        } else if (mode === 'confirm' && options.focusCancel) {
                            cancelBtn.focus();
                        } else {
                            confirmBtn.focus();
                        }
                    }, 0);
                });
            }

            confirmBtn.addEventListener('click', handleConfirm);
            cancelBtn.addEventListener('click', handleCancel);
            root.addEventListener('click', function (event) {
                if (event.target === root || event.target.classList.contains('veritas-modal-backdrop')) {
                    if (!currentConfig || currentConfig.allowBackdropClose === false) {
                        return;
                    }
                    handleCancel();
                }
            });

            return {
                alert: function (options) {
                    return openModal('alert', options).then(function () { return; });
                },
                confirm: function (options) {
                    return openModal('confirm', options).then(function (result) { return result !== false; });
                },
                prompt: function (options) {
                    return openModal('prompt', options).then(function (result) { return result; });
                }
            };
        }
        var currentOptionLayout = [];

        var connectivityThemes = {
            connecting: ['border-amber-300', 'bg-amber-50', 'text-amber-800', 'dark:border-amber-500', 'dark:bg-amber-900/20', 'dark:text-amber-100'],
            offline: ['border-red-300', 'bg-red-50', 'text-red-800', 'dark:border-red-600', 'dark:bg-red-900/20', 'dark:text-red-200'],
            recovered: ['border-green-300', 'bg-green-50', 'text-green-800', 'dark:border-green-600', 'dark:bg-green-900/20', 'dark:text-green-100']
        };
        var allConnectivityClasses = connectivityThemes.connecting.concat(connectivityThemes.offline, connectivityThemes.recovered);

        function isPreLiveVisible() {
            return preLiveCard && preLiveCard.style.display !== 'none';
        }

        function setPreLiveReconnectMessage(text) {
            // Disabled for student view - students don't need to see sync notifications
            return;
        }

        function applyConnectivityTheme(theme) {
            if (!connectivityBanner) return;
            for (var i = 0; i < allConnectivityClasses.length; i++) {
                connectivityBanner.classList.remove(allConnectivityClasses[i]);
            }
            var themeClasses = connectivityThemes[theme] || connectivityThemes.connecting;
            for (var j = 0; j < themeClasses.length; j++) {
                connectivityBanner.classList.add(themeClasses[j]);
            }
        }

        function showConnectivityState(state, options) {
            // Disabled for student view - students don't need to see sync notifications
            // Background sync continues to work normally
            return;
        }

        function hideConnectivityBanner() {
            if (!connectivityBanner) return;
            clearTimeout(connectivityHideTimer);
            connectivityBanner.classList.add('hidden');
            if (connectivitySubMessage) {
                connectivitySubMessage.textContent = '';
                connectivitySubMessage.classList.remove('opacity-0');
            }
            setPreLiveReconnectMessage('');
        }

        function stopPolling() {
            if (pollTimerId) {
                clearTimeout(pollTimerId);
                pollTimerId = null;
            }
            pollInFlight = false;
        }

        function scheduleNextPoll(delay) {
            if (isInteractionBlocked) return;
            stopPolling();
            var boundedDelay = Math.min(maxPollInterval, Math.max(1000, delay));
            var jitter = Math.random() * 0.15 * boundedDelay;
            pollTimerId = setTimeout(function () {
                pollTimerId = null;
                pollForStatus();
            }, boundedDelay + jitter);
        }

        function startPolling(immediate) {
            // Guard: Check for persisted lock
            if (sessionStorage.getItem('veritas_lock_active') === 'true') {
                if (typeof showLockEnforcementUI === 'function') {
                    showLockEnforcementUI();
                }
                return;
            }

            // POISON PILL CHECK: If lock is active, immediately show lock UI and return
            if (isPoisonPillActive()) {
                console.log('[Proctor] POISON PILL ACTIVE in startPolling - blocking resume');
                isInteractionBlocked = true;
                showLockEnforcementUI();
                startProctorPolling();
                return;
            }

            pollFailureCount = 0;
            recoveringFromOutage = false;
            if (immediate) {
                stopPolling();
                pollForStatus(true);
            } else {
                scheduleNextPoll(defaultPollInterval);
            }
        }

        function handlePostPollSuccess(data, hadFailures) {
            if (typeof data.stateVersion === 'number') {
                lastStateVersion = data.stateVersion;
            }
            if (typeof data.advisedPollIntervalMs === 'number') {
                lastAdvisedInterval = data.advisedPollIntervalMs;
            } else {
                lastAdvisedInterval = defaultPollInterval;
            }

            if (hadFailures || data.connectionHealth === 'RECOVERED_AFTER_OUTAGE') {
                showConnectivityState('recovered', {
                    message: 'Back on track - synced with your teacher.',
                    icon: 'cloud_done',
                    autoHide: 2400
                });
            } else if (data.connectionHealth === 'RECOVERING') {
                hideConnectivityBanner();
                if (isPreLiveVisible()) {
                    setPreLiveReconnectMessage('Syncing back up ‚Äî we will take off in a moment.');
                }
            } else if (!recoveringFromOutage && !hadFailures) {
                hideConnectivityBanner();
            }

            updateStudentView(data);
            var delay = Math.max(1200, Math.min(maxPollInterval, lastAdvisedInterval));
            scheduleNextPoll(delay);
        }

        function handlePollingFailure(error) {
            var messageText = (error && error.message) ? error.message : (typeof error === 'string' ? error : '');
            if (messageText && /Authentication|not enrolled|Invalid link/i.test(messageText)) {
                stopPolling();
                handleError(error);
                return;
            }

            recoveringFromOutage = true;
            var backoffMultiplier = Math.pow(1.6, Math.max(1, pollFailureCount));
            var retryDelay = Math.min(maxPollInterval, Math.round((lastAdvisedInterval || defaultPollInterval) * backoffMultiplier));
            var seconds = Math.max(1, Math.round(retryDelay / 1000));

            var online = typeof navigator !== 'undefined' ? navigator.onLine : true;
            showConnectivityState(online ? 'connecting' : 'offline', {
                message: online ? 'Reconnecting... your poll data is catching up.' : 'Offline detected - we will hold your spot and resync when you are back.',
                icon: online ? 'sync_problem' : 'signal_wifi_off',
                submessage: online ? ('Retrying in ' + seconds + 's...') : '',
                preLiveMessage: online ? 'Reconnecting‚Ä¶ syncing you back into place.' : 'Offline detected ‚Äî we will hold your spot and sync when you are back.'
            });

            scheduleNextPoll(retryDelay);
        }

        function showWaitingForNextPhase(message) {
            // Ensure parent container is visible
            if (studentContainer) {
                studentContainer.style.display = 'block';
                studentContainer.classList.remove('hidden');
            }
            // Hide question, show status
            if (questionContainer) questionContainer.style.display = 'none';
            if (statusContainer) {
                statusContainer.style.display = 'block';
                statusContainer.classList.remove('hidden');

                // Inject SVG Checkmark
                var iconEl = statusContainer.querySelector('.material-symbols-outlined');
                if (iconEl) {
                    // Replace icon with animated SVG
                    // Note: We're hacking the icon container to show our SVG
                    var checkHtml = `
                    <svg class="w-24 h-24 mx-auto mb-6 text-veritas-navy" viewBox="0 0 52 52" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle class="animate-draw-check" cx="26" cy="26" r="25" stroke="currentColor" stroke-width="2"/>
                        <path class="animate-draw-check" d="M14.1 27.2l7.1 7.2 16.7-16.8" stroke="currentColor" stroke-width="2" style="animation-delay: 0.2s"/>
                    </svg>
                    `;
                    // Temporarily replace the icon element styling or content
                    // Ideally we should have a cleaner way, but let's replace the content and remove classes that might conflict
                    iconEl.innerHTML = checkHtml;
                    iconEl.className = 'block mb-4'; // Reset material-symbols classes
                    iconEl.textContent = ''; // Remove text content
                    // Actually, replace the whole element to be safe
                    var newDiv = document.createElement('div');
                    newDiv.innerHTML = checkHtml;
                    iconEl.replaceWith(newDiv);
                    // Add a hook to restore it later? 
                    // renderStatusMessage handles restoration by resetting innerHTML/className
                }
            }
            if (statusMessage) {
                statusMessage.textContent = message || 'Response Captured';
                statusMessage.className = 'text-veritas-navy text-3xl font-bold tracking-tight animate-fade-in';
            }
            if (statusSubMessage) {
                statusSubMessage.textContent = "Data transmitted. Awaiting next phase...";
                statusSubMessage.style.display = 'block';
                statusSubMessage.className = 'text-slate-500 font-medium mt-2 animate-fade-in';
            }
            // Hide any resume controls
            var resumeControls = document.getElementById('resume-controls');
            if (resumeControls) {
                resumeControls.style.display = 'none';
            }
        }

        function pollForStatus() {
            if (isInteractionBlocked || pollInFlight) return;
            pollInFlight = true;
            var context = {
                lastStateVersion: lastStateVersion,
                lastSuccessAt: lastSuccessfulPollAt,
                failureCount: pollFailureCount,
                advisedInterval: lastAdvisedInterval,
                telemetry: ActivityMonitor.getInstance().getTelemetry()
            };

            google.script.run
                .withSuccessHandler(function (data) {
                    pollInFlight = false;
                    var hadFailures = pollFailureCount > 0 || recoveringFromOutage;
                    pollFailureCount = 0;
                    recoveringFromOutage = false;
                    lastSuccessfulPollAt = Date.now();
                    handlePostPollSuccess(data || {}, hadFailures);
                })
                .withFailureHandler(function (error) {
                    pollInFlight = false;
                    pollFailureCount += 1;
                    console.error('Polling error', error);
                    handlePollingFailure(error);
                })
                .getStudentPollStatus(SESSION_TOKEN, context);
        }

        function isSessionActive() {
            return studentContainer && studentContainer.style.display !== 'none' && entryScreen && entryScreen.style.display === 'none';
        }

        window.addEventListener('offline', function () {
            if (!isSessionActive()) return;
            recoveringFromOutage = true;
            showConnectivityState('offline', {
                message: 'Offline detected - we will hold your spot and resync when you are back.',
                icon: 'signal_wifi_off'
            });
        });

        window.addEventListener('online', function () {
            if (!isSessionActive()) return;
            showConnectivityState('connecting', {
                message: 'Reconnecting... your poll data is catching up.',
                icon: 'sync',
                submessage: 'Syncing now...'
            });
            startPolling(true);
            // Re-assert session active state if recovering
            if (isSessionActive() && !isInteractionBlocked) {
                secureSessionActive = true;
            }
        });

        if (resumeSessionBtn) {
            resumeSessionBtn.onclick = function () {
                console.log('Resume button clicked - attempting fullscreen');
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen()
                        .then(function () {
                            console.log('Fullscreen entered - confirming with server');
                            // Call studentConfirmFullscreen with the current lockVersion
                            google.script.run
                                .withSuccessHandler(function (response) {
                                    if (response.success && response.status === 'OK') {
                                        console.log('[Proctor] Server confirmed unlock via fullscreen confirmation - clearing Poison Pill');
                                        // ANTIDOTE: Clear the Poison Pill upon successful server confirmation
                                        clearPersistedLock();

                                        isInteractionBlocked = false;
                                        violationLogged = false;
                                        fullscreenEnteredOnce = false; // Reset for new fullscreen session
                                        if (proctorPollInterval) {
                                            clearInterval(proctorPollInterval);
                                            proctorPollInterval = null;
                                        }
                                        if (resumeControls) {
                                            resumeControls.style.display = 'none';
                                        }
                                        hideConnectivityBanner();
                                        startPolling(true);
                                        if (lastUnlockedState && lastUnlockedState.status && lastUnlockedState.status !== 'LOCKED' && lastUnlockedState.status !== 'AWAITING_FULLSCREEN') {
                                            updateStudentView(lastUnlockedState);
                                        }
                                    } else {
                                        console.error('Failed to confirm fullscreen:', response);
                                        statusMessage.textContent = 'Failed to resume. Please try again.';
                                    }
                                })
                                .withFailureHandler(function (error) {
                                    console.error('Error confirming fullscreen:', error);
                                    statusMessage.textContent = 'Error resuming session.';
                                })
                                .studentConfirmFullscreen(currentLockVersion, SESSION_TOKEN);
                        })
                        .catch(function (e) {
                            console.warn('Fullscreen denied on resume:', e);
                            statusMessage.textContent = 'Fullscreen is required. Please allow fullscreen and try again.';
                        });
                }
            };
        }

        if (secureExitButton) {
            secureExitButton.addEventListener('click', function () {
                exitSecureSessionNow();
            });
        }

        if (startSessionBtn) {
            console.log('Attaching onclick handler to start session button');
            startSessionBtn.onclick = function () {
                console.log('!!! BEGIN SESSION BUTTON CLICKED !!!');
                console.log('Hiding entry screen, showing student container');
                entryScreen.style.display = 'none';
                studentContainer.style.display = 'block';
                isInteractionBlocked = false;
                isTeacherBlocked = false;
                violationLogged = false;
                fullscreenEnteredOnce = false; // Reset for new session
                if (resumeControls) {
                    resumeControls.style.display = 'none';
                }

                try {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen().catch(function (e) {
                            console.warn('Fullscreen denied:', e);
                        });
                    }
                } catch (e) {
                    console.error('Fullscreen error:', e);
                }

                hideConnectivityBanner();
                startPolling(true);
            };
        } else {
            console.error('Start session button not found!');
        }

        function startProctorPolling() {
            stopPolling();
            if (proctorPollInterval) {
                clearInterval(proctorPollInterval);
            }
            proctorPollInterval = setInterval(checkProctorState, 2500);
            checkProctorState();
        }

        function checkProctorState() {
            var telemetry = ActivityMonitor.getInstance().getTelemetry();
            google.script.run
                .withSuccessHandler(function (response) {
                    if (!response.success) {
                        console.error('Proctor state check failed:', response.error);
                        return;
                    }

                    // Check if status is AWAITING_FULLSCREEN - teacher has approved unlock
                    // NOTE: We do NOT clear the Poison Pill here - only show resume prompt
                    // The Poison Pill will be cleared ONLY after successful fullscreen confirmation
                    // FIX: Accept any AWAITING_FULLSCREEN status regardless of lockVersion match
                    // This handles the force-unlock case where server creates a new lockVersion
                    if (response.status === 'AWAITING_FULLSCREEN') {
                        // Update local lockVersion to match server
                        currentLockVersion = response.lockVersion;
                        if (proctorPollInterval) {
                            clearInterval(proctorPollInterval);
                            proctorPollInterval = null;
                        }
                        showResumePrompt();
                    } else if (response.status === 'LOCKED' && response.lockVersion !== currentLockVersion) {
                        // New violation or version mismatch - update lockVersion
                        currentLockVersion = response.lockVersion;
                        showLockEnforcementUI();
                    } else if (response.status === 'BLOCKED') {
                        isTeacherBlocked = true;
                        if (response.lockVersion && response.lockVersion !== currentLockVersion) {
                            currentLockVersion = response.lockVersion;
                        }
                        showTeacherBlockedMessage();
                    } else if (response.unlock_granted === true) {
                        // ANTIDOTE: Server has EXPLICITLY granted unlock via teacher action
                        // This ONLY comes from studentConfirmFullscreen() or teacherUnblockStudent()
                        // NEVER from getStudentProctorState() polling - that was the auto-unlock bug!
                        console.log('[Proctor] Server EXPLICITLY granted unlock (unlock_granted=true) - clearing Poison Pill');
                        clearPersistedLock();

                        if (proctorPollInterval) {
                            clearInterval(proctorPollInterval);
                            proctorPollInterval = null;
                        }
                        isInteractionBlocked = false;
                        isTeacherBlocked = false;
                        violationLogged = false;
                        fullscreenEnteredOnce = false; // Reset for new fullscreen session
                        hideConnectivityBanner();
                        secureSessionActive = true; // RESUME SESSIONS MUST BE ACTIVE
                        startPolling(true);
                        if (lastUnlockedState && lastUnlockedState.status && lastUnlockedState.status !== 'LOCKED' && lastUnlockedState.status !== 'AWAITING_FULLSCREEN') {
                            updateStudentView(lastUnlockedState);
                        }
                    } else if (response.status === 'OK') {
                        // Student status is OK but no explicit unlock_granted
                        // This means either:
                        // 1. Fresh student who was never locked - OK to continue
                        // 2. Student was locked but somehow status is OK without unlock_granted - BUG, keep polling
                        // To be safe, if poison pill is active, KEEP LOCKED and keep polling.
                        if (isPoisonPillActive()) {
                            console.warn('[Proctor] Status is OK but Poison Pill still active - keeping lock (waiting for unlock_granted)');
                            showLockEnforcementUI();
                            // Keep polling - don't clear interval
                        } else {
                            // Normal case: student was never locked, continue normally
                            console.log('[Proctor] Status OK, no prior lock - continuing normally');
                            if (proctorPollInterval) {
                                clearInterval(proctorPollInterval);
                                proctorPollInterval = null;
                            }
                        }
                    }
                })
                .withFailureHandler(function (error) {
                    console.error('Proctor state check error:', error);
                })
                .getStudentProctorState(SESSION_TOKEN, telemetry);
        }

        function hideAllViews() {
            // ENHANCED VIEW MUTEX: Use both display property and hidden class for robustness
            ['entry-screen', 'secure-lobby', 'status-container', 'pre-live-card', 'student-container', 'question-container', 'individual-timed-session'].forEach(function (id) {
                var el = document.getElementById(id);
                if (el) {
                    el.style.display = 'none';
                    el.classList.add('hidden'); // Tailwind hidden utility
                }
            });
            // Ensure body overflow logic is reset unless locked
            if (!isInteractionBlocked) {
                document.body.style.overflow = '';
            }
        }

        function showView(elementId) {
            hideAllViews();
            var el = document.getElementById(elementId);
            if (el) {
                el.style.display = 'block';
                el.classList.remove('hidden');
            }
            // Also ensure parent container is visible if needed
            if (elementId !== 'entry-screen' && studentContainer) {
                studentContainer.style.display = 'block';
                studentContainer.classList.remove('hidden');
            }
        }

        function syncCalculatorVisibility(enabled) {
            var fab = document.getElementById('calc-fab');
            var win = document.getElementById('calc-window');
            if (enabled === true || enabled === 'true') {
                if (fab) fab.style.display = 'flex';
            } else {
                if (fab) fab.style.display = 'none';
                if (win) {
                    win.classList.remove('active');
                    win.style.display = 'none';
                }
            }
        }

        // =============================================================================
        // MAIN VIEW CONTROLLER (Sovereign Implementation)
        // =============================================================================

        function updateStudentView(data) {
            data = data || {};

            // CRITICAL FIX: Persist pollId globally and to sessionStorage for violation reporting
            if (data.pollId) {
                window.currentPollId = data.pollId;
                sessionStorage.setItem('veritas_active_poll_id', data.pollId);
            }

            console.log('[ViewManager] Update View State:', data);

            // --- EARLY CHECKS BEFORE HIDING VIEWS (prevents white screen) ---

            var currentIndex = typeof data.questionIndex === 'number' ? data.questionIndex : null;

            // Normalize results visibility early for deterministic guards
            var resultsVisibility = data.resultsVisibility || (data.status === 'RESULTS_REVEALED' ? 'REVEALED' : null);

            // 1. POISON PILL CHECK - Do NOT hide views if student is locked
            var poisonPillActive = false;
            try {
                poisonPillActive = sessionStorage.getItem('veritas_lock_active') === 'true';
            } catch (e) { poisonPillActive = false; }

            if (poisonPillActive) {
                if (data && data.unlock_granted === true) {
                    clearPersistedLock();
                    poisonPillActive = false;
                    if (typeof hideLockEnforcementUI === 'function') { hideLockEnforcementUI(); }
                } else {
                    // Show lock screen WITHOUT hiding other views first
                    if (typeof showLockEnforcementUI === 'function') {
                        showLockEnforcementUI();
                    }
                    isInteractionBlocked = true;
                    startProctorPolling();
                    return;
                }
            }

            // 2. SOVEREIGN LOCK CHECK - Before hiding views
            if (LockManager.isLocked()) {
                if (data.unlockApproved === true) {
                    console.log('[LockManager] Server approved unlock - Clearing Poison Pill');
                    LockManager.unlock();
                } else {
                    console.warn('[LockManager] Local Lock Active - Blocking View Update');
                    var reason = sessionStorage.getItem('lock_reason');
                    LockManager.renderLockScreen(reason);
                    return; // HALT RENDER - SECURITY BLOCK
                }
            } else if (data.isLocked || data.status === 'LOCKED') {
                // Server commanded lock
                LockManager.lock(data.lockReason || 'Server Command');
                return;
            }

            // 3. SUBMISSION GUARD - If already submitted, show waiting screen immediately (no flash)
            // Maintain submission guardrails so polling cannot rewind UI
            if (data.hasSubmitted === true && currentIndex !== null) {
                lastSubmittedQuestionIndex = currentIndex;
            }

            // If we've already submitted for this question, never re-render the prompt unless in reveal phase
            if (currentIndex !== null && lastSubmittedQuestionIndex === currentIndex && data.status === 'LIVE' && resultsVisibility !== 'REVEALED') {
                // Don't hide views - just ensure status container is visible
                if (questionContainer) questionContainer.style.display = 'none';
                showWaitingForNextPhase('Response Captured');
                return;
            }

            // --- NOW SAFE TO HIDE VIEWS AND TRANSITION ---

            hideAllViews();

            // STRICT VIEW MUTEX: prevent ghost/double screens
            ['entry-screen', 'secure-lobby', 'student-container'].forEach(function (viewId) {
                var viewEl = document.getElementById(viewId);
                if (viewEl) {
                    viewEl.style.display = 'none';
                    viewEl.classList.add('hidden');
                }
            });

            // FIREBASE INIT CHECK (Lazy)
            if (!firebaseRef && data.pollId && data.studentEmail) {
                // Now async, but that's fine, it will init in background
                initFirebaseSidecar(data.pollId, data.studentEmail);
            }

            // RESULTS / REVEAL HANDLING
            if (data.resultsVisibility === 'REVEALED' || data.status === 'RESULTS_REVEALED') {
                var normalizedStatus = data.status || 'RESULTS_REVEALED';
                data.status = normalizedStatus;
                renderResultsStage(data);
                return;
            }
            if (data.status === 'RESULTS_HOLD') {
                showWaitingForNextPhase('Results Pending Analysis');
                return;
            }

            // 3. Calculator Sync
            var calcEnabled = data.calculatorEnabled === true;
            if (window.syncCalculatorVisibility) {
                window.syncCalculatorVisibility(calcEnabled);
            }

            // 4. Session Status Handling
            if (data.status === 'CLOSED' || data.sessionPhase === 'ENDED') {
                if (window.hideCalculatorOnSessionEnd) window.hideCalculatorOnSessionEnd();
                ViewManager.show('status-container');
                renderStatusMessage('Session Concluded', 'The live session has ended. Thanks for participating!');
                return;
            }

            if (!data.sessionType && !data.pollId) {
                if (entryScreen) {
                    entryScreen.style.display = 'block';
                    entryScreen.classList.remove('hidden');
                }
                ViewManager.show('entry-screen');
                return;
            }

            // Animation for question transition
            var isNewQuestion = lastQuestionIndex !== currentIndex && currentIndex !== null;
            if (isNewQuestion) {
                lastQuestionIndex = currentIndex;
                var sContainer = document.getElementById('student-container');
                if (sContainer) {
                    sContainer.classList.remove('motion-slide-in-right');
                    void sContainer.offsetWidth; // Force reflow
                    sContainer.classList.add('motion-slide-in-right');
                }
            }

            if (studentContainer) {
                studentContainer.style.display = 'block';
                studentContainer.classList.remove('hidden');
            }

            // 5. Route to specific view handlers
            var isSecure = (data.sessionType === 'SECURE_ASSESSMENT' || data.sessionType === 'SECURE');

            if (isSecure) {
                // Secure Logic
                if (data.status === 'LOBBY' || data.sessionPhase === 'LOBBY') {
                    var lobbyView = document.getElementById('secure-lobby');
                    if (lobbyView) {
                        lobbyView.style.display = 'block';
                        lobbyView.classList.remove('hidden');
                    }
                    ViewManager.show('secure-lobby');
                    renderSecureLobby(data);
                } else {
                    ViewManager.show('individual-timed-session');
                    showIndividualTimedView(data);
                }
            } else {
                // Live Poll Logic (Legacy)
                if (data.sessionPhase === 'LOBBY') {
                    ViewManager.show('pre-live-card');
                    updatePreLiveCard(data);
                } else {
                    ViewManager.show('question-container');

                    // Legacy UI updates
                    if (data.status === 'PRE_LIVE') {
                        liveSessionActive = false;
                        hasAnsweredCurrent = false;
                        pendingSubmission = false;
                        currentQuestionKey = null;
                        toggleSecureLayout(false);
                        if (questionProgressEl) questionProgressEl.textContent = 'QUESTION 1 OF ?';
                        ViewManager.show('pre-live-card'); // Redundant but safe
                    } else {
                        if (pendingMetacogQuestionIndex === currentIndex && metacogSubmittedFor !== currentIndex) {
                            showConfidenceQuestion(data.pollId, currentIndex);
                            return;
                        }

                        if (data.hasSubmitted === true && currentIndex !== null) {
                            showWaitingForNextPhase('Response Captured');
                            return;
                        }
                        renderQuestion(data);
                    }
                }
            }

            // Resume controls logic (legacy cleanup)
            var resumeControls = document.getElementById('resume-controls');
            if (resumeControls) resumeControls.style.display = 'none';
        }

        // =============================================================================
        // LIVE POLL QUESTION RENDERER (FIX: Was undefined, causing blank question view)
        // =============================================================================
        function renderQuestion(data) {
            // FIX TASK B: LOCK GUARD - If locked, do not render question content
            // This prevents lock bypass via question rendering in Live Poll mode
            if (LockManager.isLocked()) {
                console.log('[Proctor] renderQuestion BLOCKED - Lock active');
                LockManager.renderLockScreen(sessionStorage.getItem('lock_reason'));
                return; // HALT RENDER - SECURITY BLOCK
            }

            // Defensive guard: if critical elements are missing, show error
            if (!questionContainer || !optionsList || !questionTextEl) {
                console.error('[renderQuestion] Critical DOM elements missing');
                var errorOverlay = document.getElementById('render-error-overlay');
                if (!errorOverlay) {
                    errorOverlay = document.createElement('div');
                    errorOverlay.id = 'render-error-overlay';
                    errorOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:9999;display:flex;align-items:center;justify-content:center;flex-direction:column;color:white;font-family:sans-serif;';
                    errorOverlay.innerHTML = '<h2 style="font-size:24px;margin-bottom:16px;">Unable to Load Question</h2><p style="max-width:400px;text-align:center;">Critical UI elements are missing. Please refresh the page or contact your teacher.</p>';
                    document.body.appendChild(errorOverlay);
                }
                return;
            }

            currentPollState = data;
            console.log('[renderQuestion] Rendering Live Poll question:', data);

            // Derive question key for change detection
            var resetTimestamp = (data.metadata && data.metadata.resetAt) ? data.metadata.resetAt : '';
            var newQuestionKey = data.pollId + ':' + data.questionIndex + ':' + resetTimestamp;

            // Check if question has changed
            var questionChanged = (currentQuestionKey !== newQuestionKey);
            if (questionChanged) {
                console.log('[renderQuestion] Question changed from', currentQuestionKey, 'to', newQuestionKey);
                currentQuestionKey = newQuestionKey;
                hasAnsweredCurrent = !!data.hasSubmitted;
                pendingSubmission = false;
                currentOptionLayout = [];
                liveSessionActive = true;
                pendingMetacogQuestionIndex = null;
                metacogSubmittedFor = null;

                // Initialize activity tracker for this question
                activityTracker.init(data.pollId, data.sessionId || '', data.questionIndex);
            }

            // Update metacognition setting for this question
            currentMetacognitionEnabled = !!data.metacognitionEnabled;

            // Update question progress (fixes "QUESTION --" display)
            updateQuestionProgress(data.questionIndex, data.totalQuestions);

            // Show question container, hide status
            questionContainer.style.display = 'block';
            if (statusContainer) statusContainer.style.display = 'none';

            // Set question text with fallback and visibility check
            if (questionTextEl) {
                var qText = data.questionText || data.text || data.stem || '';
                if (!qText && data.options && data.options.length > 0) {
                    // Fallback: If options exist but text is missing, show something
                    qText = "[Question Text Missing]";
                    console.warn('[renderQuestion] Question text is missing/empty', data);
                }
                questionTextEl.textContent = qText;
                questionTextEl.style.display = 'block'; // Force visibility
                questionTextEl.classList.remove('hidden');
            }

            // Handle question image
            var hasQuestionImage = !!data.questionImageURL;
            if (questionImageEl) {
                if (hasQuestionImage) {
                    questionImageEl.src = data.questionImageURL;
                    questionImageEl.style.display = 'block';
                } else {
                    questionImageEl.style.display = 'none';
                }
            }
            if (questionLayout) {
                questionLayout.classList.toggle('no-image', !hasQuestionImage);
            }
            if (questionVisual) {
                questionVisual.style.display = hasQuestionImage ? 'flex' : 'none';
            }

            // Hide subline (used for results stage)
            if (questionSublineEl) {
                questionSublineEl.classList.add('hidden');
                questionSublineEl.textContent = '';
            }
            if (noResponsesMessageEl) {
                noResponsesMessageEl.classList.add('hidden');
                noResponsesMessageEl.textContent = '';
            }

            // Clear results decorations
            questionContainer.classList.remove('results-stage', 'showing-results');

            // Render options only if question changed or options empty
            if (questionChanged || optionsList.children.length === 0) {
                var options = data.options || [];
                var letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];

                // Apply shuffle if enabled (and question just changed)
                if (questionChanged && data.shuffleOptions) {
                    options = shuffle(options.slice());
                }

                optionsList.innerHTML = '';
                currentOptionLayout = [];

                options.forEach(function (option, index) {
                    var normalized = {
                        text: (typeof option === 'string') ? option : (option.text || ''),
                        imageURL: (typeof option === 'object') ? (option.imageURL || option.imageUrl || '') : ''
                    };
                    var letter = letters[index] || (index + 1).toString();
                    var btn = createOptionButton(normalized, letter, data.pollId, data.questionIndex);

                    // Disable if already answered
                    if (hasAnsweredCurrent) {
                        btn.disabled = true;
                        btn.classList.add('answer-option-disabled');
                    }

                    var listItem = document.createElement('li');
                    listItem.appendChild(btn);
                    optionsList.appendChild(listItem);

                    currentOptionLayout.push({
                        text: normalized.text,
                        imageURL: normalized.imageURL
                    });
                });
            } else if (hasAnsweredCurrent) {
                // Student has already answered - show waiting screen instead of question
                showWaitingForNextPhase('Response Captured');
                return;
            }
        }

        function submitAnswer(pollId, questionIndex, answerText) {
            console.log('=== SUBMIT ANSWER CALLED ===');
            console.log('currentMetacognitionEnabled:', currentMetacognitionEnabled);
            console.log('answerText:', answerText);

            if (isInteractionBlocked) {
                return;
            }
            if (hasAnsweredCurrent) {
                return;
            }

            var buttons = optionsList.querySelectorAll('button');
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].disabled = true;
                if (buttons[i].dataset.answerText === answerText) {
                    buttons[i].className = optionSelectedClass;
                } else {
                    buttons[i].className = optionDisabledClass;
                }
            }

            // Check if metacognition is enabled for this question
            if (currentMetacognitionEnabled) {
                console.log('Metacognition is enabled - showing confidence question');
                pendingAnswerText = answerText;
                questionContainer.style.display = 'none';
                showConfidenceQuestion(pollId, questionIndex);
            } else {
                console.log('Metacognition is NOT enabled - submitting answer directly');
                hasAnsweredCurrent = true;
                pendingSubmission = true;
                // Show immediate feedback while waiting for server response
                statusContainer.style.display = 'block';
                questionContainer.style.display = 'none';
                if (statusMessage) {
                    var waitPhrases = [
                        "Locking in your genius...", "Securing your brilliance...",
                        "Beaming answer to HQ...", "Writing to the digital ledger..."
                    ];
                    statusMessage.textContent = waitPhrases[Math.floor(Math.random() * waitPhrases.length)];
                    statusMessage.className = 'text-veritas-navy text-2xl font-bold animate-text-shimmer';
                }
                if (statusSubMessage) {
                    statusSubMessage.textContent = 'Please wait while we confirm your submission.';
                    statusSubMessage.style.display = 'block';
                    statusSubMessage.className = 'text-slate-500 text-sm mt-2 animate-pulse';
                }
                submitAnswerToServer(pollId, questionIndex, answerText, null);
            }
        }

        function showConfidenceQuestion(pollId, questionIndex) {
            statusContainer.style.display = 'block';
            questionContainer.style.display = 'none';

            pendingMetacogQuestionIndex = questionIndex;

            statusMessage.textContent = 'How confident are you in your answer?';
            statusMessage.className = 'text-gray-800 text-xl font-semibold mb-4';

            if (statusSubMessage) {
                statusSubMessage.innerHTML = '<div class="confidence-selector mt-6 flex flex-col gap-3">' +
                    '<button class="confidence-btn h-14 px-6 rounded-xl bg-red-500/20 hover:bg-red-500/30 text-gray-900 border-2 border-red-500/40 hover:border-red-500/60 transition-all font-semibold text-lg" data-confidence="guessing">' +
                    '<span class="mr-2">ü§î</span> Guessing' +
                    '</button>' +
                    '<button class="confidence-btn h-14 px-6 rounded-xl bg-yellow-500/20 hover:bg-yellow-500/30 text-gray-900 border-2 border-yellow-500/40 hover:border-yellow-500/60 transition-all font-semibold text-lg" data-confidence="somewhat-sure">' +
                    '<span class="mr-2">ü§∑</span> Somewhat Sure' +
                    '</button>' +
                    '<button class="confidence-btn h-14 px-6 rounded-xl bg-blue-500/20 hover:bg-blue-500/30 text-gray-900 border-2 border-blue-500/40 hover:border-blue-500/60 transition-all font-semibold text-lg" data-confidence="very-sure">' +
                    '<span class="mr-2">üëç</span> Very Sure' +
                    '</button>' +
                    '<button class="confidence-btn h-14 px-6 rounded-xl bg-green-500/20 hover:bg-green-500/30 text-gray-900 border-2 border-green-500/40 hover:border-green-500/60 transition-all font-semibold text-lg" data-confidence="certain">' +
                    '<span class="mr-2">üíØ</span> Absolutely Certain' +
                    '</button>' +
                    '</div>';
                statusSubMessage.style.display = 'block';
                statusSubMessage.className = 'text-gray-700 text-base mt-4';

                var confidenceBtns = statusSubMessage.querySelectorAll('.confidence-btn');
                for (var i = 0; i < confidenceBtns.length; i++) {
                    confidenceBtns[i].addEventListener('click', function (event) {
                        event.preventDefault();
                        var confidence = this.dataset.confidence;
                        submitAnswerWithConfidence(pollId, questionIndex, pendingAnswerText, confidence);
                    });
                }
            }
        }

        if (secureBeginBtn) {
            secureBeginBtn.addEventListener('click', handleSecureBeginClick);
        }

        if (secureAccessCodeInput) {
            secureAccessCodeInput.addEventListener('input', function () {
                setSecureAccessError('');
            });
        }

        function submitAnswerWithConfidence(pollId, questionIndex, answerText, confidence) {
            // Track answer submission
            activityTracker.recordAnswerSubmitted(answerText, confidence);

            hasAnsweredCurrent = true;
            pendingSubmission = true;
            metacogSubmittedFor = questionIndex;
            pendingMetacogQuestionIndex = null;
            statusMessage.textContent = 'Transmitting your response...';
            statusMessage.className = 'text-gray-900 text-2xl font-semibold';
            if (statusSubMessage) {
                statusSubMessage.innerHTML = '';
                statusSubMessage.style.display = 'none';
            }
            submitAnswerToServer(pollId, questionIndex, answerText, confidence);
        }

        function submitAnswerToServer(pollId, questionIndex, answerText, confidence) {
            // Live Poll - FAST PATH: Firebase First
            submitAnswerToFirebase(pollId, questionIndex, answerText, confidence)
                .then(function (firebaseResult) {
                    if (firebaseResult && firebaseResult.success) {
                        console.log('[Firebase] Fast write successful (Live Poll)');
                        pendingAnswerText = null;
                        statusMessage.textContent = 'Response Received';
                        statusMessage.className = 'text-green-700 text-2xl font-semibold';
                        if (statusSubMessage) {
                            statusSubMessage.textContent = 'Recorded via Firebase. Syncing to backup...';
                            statusSubMessage.style.display = 'block';
                            statusSubMessage.className = 'text-gray-700 text-lg mt-4';
                        }
                        // Background sync to Sheets
                        syncToSheets(pollId, questionIndex, answerText, confidence);
                    } else {
                        console.warn('[Firebase] Fast write failed, falling back to Sheets');
                        syncToSheets(pollId, questionIndex, answerText, confidence);
                    }
                });

            function syncToSheets(pId, qIdx, text, conf) {
                google.script.run
                    .withSuccessHandler(function (response) {
                        if (!response.success) {
                            console.error('[Sheets] Backup sync failed:', response.error);
                            // If primary Firebase succeeded, we don't necessarily need to error UI
                            // but we should log it. If both failed, then show error.
                            if (statusMessage.textContent !== 'Response Received') {
                                handleLivePollError(response.error);
                            }
                        } else {
                            console.log('[Sheets] Backup sync successful');
                        }
                    })
                    .withFailureHandler(function (error) {
                        console.error('[Sheets] Network error during backup sync:', error);
                        if (statusMessage.textContent !== 'Response Received') {
                            handleLivePollError(error);
                        }
                    })
                    .submitLivePollAnswer(pId, qIdx, text, SESSION_TOKEN, conf);
            }

            function handleLivePollError(error) {
                hasAnsweredCurrent = false;
                pendingSubmission = false;
                pendingAnswerText = null;
                statusMessage.textContent = error || 'We hit a hiccup. Try again?';
                statusMessage.className = 'text-red-700 text-2xl font-semibold';
                if (statusSubMessage) {
                    statusSubMessage.style.display = 'none';
                    statusSubMessage.textContent = '';
                }
                setTimeout(function () {
                    if (!isInteractionBlocked) {
                        questionContainer.style.display = 'block';
                        statusContainer.style.display = 'none';
                        var buttons = optionsList.querySelectorAll('button');
                        for (var i = 0; i < buttons.length; i++) {
                            buttons[i].disabled = false;
                            buttons[i].className = optionBaseClass;
                        }
                    }
                }, 2000);
            }
        }

        function shuffle(array) {
            var arr = array.slice();
            for (var i = arr.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            return arr;
        }

        function createOptionButton(option, letter, pollId, questionIndex) {
            var btn = document.createElement('button');
            btn.type = 'button';
            btn.className = optionBaseClass;
            btn.dataset.answerText = option.text || '';

            var displayText = (option.text || '').trim();

            var content = '';
            if (option.imageURL) {
                content += '<img src="' + escapeHtml(option.imageURL) + '" alt="Answer ' + letter + '" class="option-image" referrerpolicy="no-referrer">';
            }
            content += '<div class="option-leading">';
            content += '<div class="letter-badge" aria-hidden="true">' + letter + '</div>';
            content += '<div class="option-body">';
            content += '<div class="option-text-wrapper">';
            if (displayText) {
                // Remove carriage returns and normalize line endings before converting to <br>
                var cleanText = displayText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                content += '<p class="option-text">' + escapeHtml(cleanText).replace(/\n/g, '<br>') + '</p>';
            }
            content += '<span class="sr-only result-announcement"></span>';
            content += '</div>';
            content += '</div>';
            content += '</div>';

            // New Review Mode Elements
            content += '<div class="result-metadata">';
            content += '<div class="percentage-flag" style="display:none"></div>';
            content += '<div class="result-icon-marker"></div>';
            content += '</div>';
            content += '<div class="result-badges"></div>';

            btn.innerHTML = content;
            btn.addEventListener('click', function (event) {
                if (event && event.target && event.target.closest('.option-image')) {
                    return;
                }

                // Track option click
                var optionIndex = Array.from(btn.parentElement.parentElement.children).indexOf(btn.parentElement);
                activityTracker.recordOptionClick(optionIndex, option.text);

                submitAnswer(pollId, questionIndex, option.text);
            });

            return btn;
        }

        function resetResultDecorations() {
            if (questionContainer) {
                questionContainer.classList.remove('results-stage', 'showing-results', 'review-mode');
                // Remove ribbon if exists
                var ribbon = questionContainer.querySelector('.review-ribbon-strip');
                if (ribbon) ribbon.remove();
            }
            // Disable flashlight
            var flashlight = document.getElementById('flashlight-overlay');
            if (flashlight) flashlight.style.display = 'none';

            if (questionSublineEl) {
                questionSublineEl.classList.add('hidden');
                questionSublineEl.textContent = '';
            }
            if (noResponsesMessageEl) {
                noResponsesMessageEl.classList.add('hidden');
                noResponsesMessageEl.textContent = '';
            }
            if (!optionsList) return;
            var buttons = optionsList.querySelectorAll('button');
            buttons.forEach(function (btn) {
                btn.disabled = false;
                btn.className = optionBaseClass;
                btn.classList.remove('result-readonly', 'result-correct', 'result-incorrect', 'result-your-choice', 'result-neutral');

                // Clear new elements
                var flag = btn.querySelector('.percentage-flag');
                if (flag) { flag.style.display = 'none'; flag.textContent = ''; }

                var marker = btn.querySelector('.result-icon-marker');
                if (marker) marker.textContent = '';

                var badges = btn.querySelector('.result-badges');
                if (badges) badges.innerHTML = '';
            });
        }

        function ensureOptionsRenderedForResults(data) {
            if (!optionsList) return;
            if (optionsList.children.length > 0) {
                return;
            }

            var baseOptions = currentOptionLayout.length > 0 ? currentOptionLayout : (data.options || []);
            var letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            optionsList.innerHTML = '';
            currentOptionLayout = [];

            baseOptions.forEach(function (option, index) {
                var normalized = {
                    text: option.text || option,
                    imageURL: option.imageURL || option.imageUrl || ''
                };
                var letter = letters[index] || (index + 1).toString();
                var btn = createOptionButton(normalized, letter, data.pollId, data.questionIndex);
                btn.disabled = true;
                btn.classList.add('result-readonly');
                var listItem = document.createElement('li');
                listItem.appendChild(btn);
                optionsList.appendChild(listItem);
                currentOptionLayout.push({
                    text: normalized.text || '',
                    imageURL: normalized.imageURL || ''
                });
            });
        }

        function decorateOptionsForResults(data) {
            if (!optionsList) return;
            var totalResponses = typeof data.totalResponses === 'number' ? data.totalResponses : 0;
            var percentages = data.resultPercentages || {};
            var buttons = optionsList.querySelectorAll('button');

            buttons.forEach(function (btn) {
                var answerText = btn.dataset.answerText || '';
                btn.disabled = true;
                btn.className = optionBaseClass + ' result-readonly';
                btn.classList.remove('result-correct', 'result-incorrect', 'result-your-choice');

                var srOnly = btn.querySelector('.result-announcement');
                if (srOnly) srOnly.textContent = '';

                if (data.status !== 'RESULTS_REVEALED') {
                    return;
                }

                var percentage = typeof percentages[answerText] === 'number' ? percentages[answerText] : 0;

                // Update Flag
                var flag = btn.querySelector('.percentage-flag');
                if (flag) {
                    flag.style.display = 'block';
                    // Always show flag for every option as per "Percentages as Flags" requirement
                    if (totalResponses > 0 || percentage > 0) {
                        flag.textContent = percentage + '%';
                    } else {
                        flag.textContent = '0%';
                    }
                }

                var isCorrect = data.correctAnswer && answerText === data.correctAnswer;
                var hasStudentAnswer = data.studentAnswer !== undefined && data.studentAnswer !== null && data.studentAnswer !== '';
                var isStudentChoice = hasStudentAnswer && answerText === data.studentAnswer;
                var studentIsCorrect = (data.studentIsCorrect === null || data.studentIsCorrect === undefined)
                    ? null
                    : !!data.studentIsCorrect;

                // State Classes
                if (isCorrect) {
                    btn.classList.add('result-correct');
                } else if (isStudentChoice && (studentIsCorrect === false || !isCorrect)) {
                    btn.classList.add('result-incorrect');
                } else {
                    // Neutral/Unselected options
                    btn.classList.add('result-neutral');
                }

                // Markers (Check/X)
                var marker = btn.querySelector('.result-icon-marker');
                if (marker) {
                    if (isCorrect) {
                        marker.textContent = 'check_circle'; // Green Check
                        marker.parentElement.parentElement.classList.add('result-correct'); // reinforce parent
                    } else if (isStudentChoice && (studentIsCorrect === false || !isCorrect)) {
                        marker.textContent = 'cancel'; // Red X
                        marker.parentElement.parentElement.classList.add('result-incorrect');
                    } else {
                        marker.textContent = ''; // No icon for others
                    }
                }

                // Badges
                var badgesContainer = btn.querySelector('.result-badges');
                if (badgesContainer) {
                    badgesContainer.innerHTML = '';
                    if (isStudentChoice) {
                        var badge = document.createElement('span');
                        badge.className = 'badge-pill badge-your-choice';
                        badge.textContent = 'Your Choice';
                        badgesContainer.appendChild(badge);
                    }
                    if (isCorrect) {
                        var badge = document.createElement('span');
                        badge.className = 'badge-pill badge-correct';
                        badge.textContent = 'Correct';
                        badgesContainer.appendChild(badge);
                    }
                }

                // SR Announcement
                if (srOnly) {
                    var srParts = [];
                    if (isCorrect) srParts.push('Correct answer');
                    if (isStudentChoice) srParts.push('Your selection');
                    srParts.push(percentage + '% of class selected this choice');
                    srOnly.textContent = srParts.join('. ') + '.';
                }
            });
        }

        // Flashlight Logic
        var flashlightInitialized = false;
        function initFlashlight() {
            if (flashlightInitialized) return;
            var overlay = document.getElementById('flashlight-overlay');
            if (!overlay) return;

            function updateSpotlight(x, y) {
                overlay.style.setProperty('--x', x + 'px');
                overlay.style.setProperty('--y', y + 'px');
            }

            document.addEventListener('mousemove', function (e) {
                if (overlay.style.display !== 'none') {
                    requestAnimationFrame(function () {
                        updateSpotlight(e.clientX, e.clientY);
                    });
                }
            });

            document.addEventListener('touchmove', function (e) {
                if (overlay.style.display !== 'none' && e.touches.length > 0) {
                    requestAnimationFrame(function () {
                        updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
                    });
                }
            }, { passive: true });

            flashlightInitialized = true;
        }

        function renderResultsStage(data) {
            currentPollState = data;
            var resetTimestamp = (data.metadata && data.metadata.resetAt) ? data.metadata.resetAt : '';
            currentQuestionKey = data.pollId + ':' + data.questionIndex + ':' + resetTimestamp;
            hasAnsweredCurrent = !!data.hasSubmitted;

            // Ensure parent container is visible for results display
            if (studentContainer) {
                studentContainer.style.display = 'block';
                studentContainer.classList.remove('hidden');
            }

            questionContainer.style.display = 'block';
            questionContainer.classList.remove('hidden');
            statusContainer.style.display = 'none';

            var qNum = (data.questionIndex || 0) + 1;
            var qTotal = data.totalQuestions || '?';
            updateQuestionProgress(data.questionIndex, data.totalQuestions);
            if (questionTextEl) {
                questionTextEl.textContent = data.questionText || '';
            }
            var hasQuestionImage = !!data.questionImageURL;
            if (questionImageEl) {
                if (hasQuestionImage) {
                    questionImageEl.src = data.questionImageURL;
                    questionImageEl.style.display = 'block';
                } else {
                    questionImageEl.style.display = 'none';
                }
            }
            if (questionLayout) {
                questionLayout.classList.toggle('no-image', !hasQuestionImage);
            }
            if (questionVisual) {
                questionVisual.style.display = hasQuestionImage ? 'flex' : 'none';
            }

            // Remove old styling text
            if (questionSublineEl) {
                questionSublineEl.classList.add('hidden'); // Removed "Shown after responses closed."
            }

            if (data.status === 'RESULTS_REVEALED' && noResponsesMessageEl) {
                if ((data.totalResponses || 0) === 0) {
                    noResponsesMessageEl.textContent = 'No responses recorded for this question.';
                    noResponsesMessageEl.classList.remove('hidden');
                } else {
                    noResponsesMessageEl.classList.add('hidden');
                    noResponsesMessageEl.textContent = '';
                }
            } else if (noResponsesMessageEl) {
                noResponsesMessageEl.classList.add('hidden');
                noResponsesMessageEl.textContent = '';
            }

            ensureOptionsRenderedForResults(data);

            questionContainer.classList.add('results-stage', 'review-mode');

            // Add Review Ribbon
            if (!questionContainer.querySelector('.review-ribbon-strip')) {
                var ribbon = document.createElement('div');
                ribbon.className = 'review-ribbon-strip animate-fade-in';
                ribbon.textContent = 'REVIEW';
                questionContainer.appendChild(ribbon);
            }

            // Enable Flashlight Mode
            var flashlight = document.getElementById('flashlight-overlay');
            if (flashlight) {
                flashlight.style.display = 'block';
                initFlashlight();
                // Set initial position to center or last known
                flashlight.style.setProperty('--x', (window.innerWidth / 2) + 'px');
                flashlight.style.setProperty('--y', (window.innerHeight / 2) + 'px');
            }

            questionContainer.classList.remove('showing-results');
            if (data.status === 'RESULTS_REVEALED') {
                requestAnimationFrame(function () {
                    questionContainer.classList.add('showing-results');
                });
            }

            decorateOptionsForResults(data);
        }

        function escapeHtml(text) {
            if (!text) return '';
            var div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showStatusPanel(options) {
            options = options || {};
            hideConnectivityBanner();
            hideSecureLobby();
            if (studentContainer) studentContainer.style.display = 'block';
            if (entryScreen) entryScreen.style.display = 'none';
            if (questionContainer) questionContainer.style.display = 'none';
            if (secureFocusContainer) secureFocusContainer.style.display = 'none';
            if (studentLoader) studentLoader.style.display = 'none';
            if (statusContainer) statusContainer.style.display = 'block';

            // Theme Handling
            var isDark = options.theme === 'dark';
            var statusCard = statusContainer ? statusContainer.querySelector('.status-card') : null;

            if (isDark) {
                // Apply Dark Theme
                if (statusContainer) {
                    statusContainer.classList.add('bg-gradient-to-br', 'from-slate-900', 'via-slate-800', 'to-slate-900', 'fixed', 'inset-0', 'z-[9000]', 'flex', 'items-center', 'justify-center');
                    statusContainer.classList.remove('text-center', 'py-12'); // Remove default layout
                }
                if (statusCard) {
                    statusCard.classList.remove('bg-white', 'border-gray-200', 'shadow-2xl', 'max-w-3xl');
                    statusCard.classList.add('bg-transparent', 'border-0', 'shadow-none', 'max-w-2xl', 'w-full');
                    // Making it transparent to match the "You Stepped Out" look which sits on the background
                    // OR if we want a card: bg-slate-800 border-slate-700
                }
                // Hide the Student Header if in full overlay mode
                var header = document.querySelector('.student-header');
                if (header) header.style.display = 'none';
            } else {
                // Revert to Light Theme
                if (statusContainer) {
                    statusContainer.classList.remove('bg-gradient-to-br', 'from-slate-900', 'via-slate-800', 'to-slate-900', 'fixed', 'inset-0', 'z-[9000]', 'flex', 'items-center', 'justify-center');
                    statusContainer.classList.add('text-center', 'py-12');
                }
                if (statusCard) {
                    statusCard.classList.add('bg-white', 'border-gray-200', 'shadow-2xl', 'max-w-3xl');
                    statusCard.classList.remove('bg-transparent', 'border-0', 'shadow-none', 'max-w-2xl', 'w-full', 'bg-slate-800', 'border-slate-700');
                }
                var header = document.querySelector('.student-header');
                if (header) header.style.display = ''; // Restore
            }

            if (statusMessage) {
                statusMessage.textContent = options.message || '';
                statusMessage.className = options.messageClass || (isDark ? 'text-white text-3xl font-bold tracking-tight' : 'text-gray-900 text-2xl font-semibold');
            }
            if (statusSubMessage) {
                if (options.subtext) {
                    statusSubMessage.style.display = 'block';
                    statusSubMessage.textContent = options.subtext;
                    statusSubMessage.className = options.subClass || (isDark ? 'text-gray-300 text-lg mt-4 max-w-md mx-auto leading-relaxed' : 'text-gray-700 text-lg mt-4');
                } else {
                    statusSubMessage.style.display = 'none';
                    statusSubMessage.textContent = '';
                }
            }
            var iconEl = statusContainer ? statusContainer.querySelector('.material-symbols-outlined') : null;
            if (iconEl) {
                iconEl.textContent = options.icon || 'info';
                // Wrap icon in a circle for dark mode to match Lock screen
                if (isDark) {
                    // Check if already wrapped, if not, we can't easily wrap structure here without rewriting innerHTML.
                    // Instead, just style the icon itself to be large and colored.
                    // The Lock screen uses a circle container: <div class="h-20 w-20 bg-amber-900/20 ...">
                    // Currently showStatusPanel assumes simple icon element.
                    // Let's just style the icon nicely.
                    iconEl.className = 'material-symbols-outlined text-7xl mb-6 inline-block ' + (options.iconClass || 'text-emerald-400');
                } else {
                    iconEl.className = 'material-symbols-outlined text-6xl mb-4 inline-block ' + (options.iconClass || 'text-veritas-navy');
                }
            }
            if (resumeControls) {
                resumeControls.style.display = options.showResume ? 'block' : 'none';
            }
            if (secureExitControls) {
                if (options.showExitAction) {
                    secureExitControls.classList.remove('hidden');
                    if (secureExitDescription) {
                        secureExitDescription.textContent = options.exitActionDescription || 'Click below to exit fullscreen and close the secure window.';
                        if (isDark) secureExitDescription.className = 'text-gray-400 text-sm mb-2';
                    }
                    if (secureExitLabel) {
                        secureExitLabel.textContent = options.exitActionLabel || 'Exit Secure Session';
                    }
                } else {
                    secureExitControls.classList.add('hidden');
                }
            }
            if (document && document.body) {
                if (options.lockScroll) {
                    document.body.classList.add('secure-overlay-active');
                } else {
                    document.body.classList.remove('secure-overlay-active');
                }
            }
        }

        function showLockedMessage(message, subMessage) {
            console.log('Showing locked message');
            stopPolling();
            recoveringFromOutage = false;
            // Professional lock message with science-themed copy
            showStatusPanel({
                icon: 'lock',
                iconClass: 'text-red-600',
                message: message || 'Assessment Paused',
                messageClass: 'text-gray-900 text-2xl font-bold',
                subtext: subMessage || 'Proctoring protocol triggered. Your teacher can see this and will grant re-entry.',
                subClass: 'text-gray-800 text-base mt-4 whitespace-pre-line',
                showResume: false,
                lockScroll: true
            });
            isTeacherBlocked = false;
        }

        /**
         * VERITAS UI CONFIGURATION
         * Theme: "Clear Protocol + Calm Guide" (Hybrid)
         * Tone: Warm but Precise. Human but Authoritative.
         */
        const UX_COPY = {
            // VIOLATION
            LOCKED: {
                title: "You Stepped Out",
                icon: "door_open",
                body: "The session detected activity outside this window.",
                footer: "This was flagged automatically. Your instructor can bring you back in.",
                badge: "OUTSIDE THE ROOM",
                statusLight: "LINK ACTIVE"
            },
            // LOBBY
            PRE_LIVE: {
                title: "Checked In",
                icon: "how_to_reg",
                body: "You're in the room. Waiting for the green light."
            },
            // SUBMITTED
            RESPONSE_SUBMITTED: {
                title: "Answer Sent",
                icon: "outgoing_mail",
                body: "Recorded. Sit back while the class catches up."
            },
            // REVEAL
            WAITING_FOR_REVEAL: {
                title: "Time's Up",
                icon: "timer_off",
                body: "Answers are sealed. Reveal is in your instructor's hands."
            },
            // TRANSITION
            BETWEEN_QUESTIONS: {
                title: "Switching Gears",
                icon: "swap_horiz",
                body: "Next question on deck."
            }
        };

        // --- AMBER LOCK SCREEN RENDERER ---
        function showLockEnforcementUI(reason) {
            var container = document.getElementById('lock-overlay');
            if (!container) return;

            // Reset opacity to ensure visibility (cleanup from old trap code)
            document.body.style.opacity = '1';
            container.style.display = 'flex';

            // SECURITY FIX: Escape reason to prevent XSS (even though currently app-controlled)
            // This protects against future refactoring where user-controlled data might flow here
            var safeReason = reason ? escapeHtml(reason) : UX_COPY.LOCKED.body;

            container.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full w-full max-w-2xl mx-auto p-8 animate-fade-in text-center">

                    <div class="h-20 w-20 bg-amber-900/20 rounded-full flex items-center justify-center mb-6 border-2 border-amber-700">
                        <span class="material-symbols-outlined text-4xl text-amber-400">
                            ${UX_COPY.LOCKED.icon}
                        </span>
                    </div>

                    <h1 class="text-3xl font-bold text-white mb-2 tracking-tight">
                        ${UX_COPY.LOCKED.title}
                    </h1>

                    <div class="w-full bg-amber-900/10 border-l-4 border-amber-500 p-5 my-6 text-left rounded-r-md">
                        <p class="text-xs font-semibold text-amber-400 uppercase tracking-wide mb-1">
                            ${UX_COPY.LOCKED.badge}
                        </p>
                        <p class="text-lg text-gray-100">
                            ${safeReason}
                        </p>
                    </div>

                    <p class="text-base text-gray-400">
                        ${UX_COPY.LOCKED.footer}
                    </p>

                    <div class="mt-8 flex items-center gap-2 text-xs text-gray-500 font-medium">
                        <span class="h-2 w-2 rounded-full bg-emerald-500 animate-pulse"></span>
                        <span>${UX_COPY.LOCKED.statusLight}</span>
                    </div>
                </div>
            `;
        }

        /**
         * Hide the lock enforcement overlay
         */
        function hideLockEnforcementUI() {
            var container = document.getElementById('lock-overlay');
            if (container) {
                container.style.display = 'none';
                container.innerHTML = '';
            }
            // Reset body opacity in case it was hidden by snipping trap
            document.body.style.opacity = '1';
        }

        /**
         * Render a status message in the status container
         * Used for session ended, waiting states, etc.
         */
        function renderStatusMessage(title, message, options) {
            options = options || {};
            var icon = options.icon || 'check_circle';
            var iconClass = options.iconClass || 'text-veritas-navy';

            if (statusContainer) {
                statusContainer.style.display = 'block';
            }
            if (questionContainer) {
                questionContainer.style.display = 'none';
            }
            if (statusMessage) {
                statusMessage.textContent = title || 'Status';
                statusMessage.className = 'text-gray-900 text-2xl font-semibold';
            }
            if (statusSubMessage) {
                statusSubMessage.textContent = message || '';
                statusSubMessage.style.display = message ? 'block' : 'none';
                statusSubMessage.className = 'text-gray-700 text-lg mt-4';
            }

            // Update the icon
            // Update the icon
            var statusCard = statusContainer ? statusContainer.querySelector('.status-card') : null;
            if (statusCard) {
                // Check if we need to restore the original icon span (if it was replaced by SVG)
                var iconContainer = statusCard.querySelector('.material-symbols-outlined') || statusCard.querySelector('div:first-child');

                // If we found a container but it's not the span we expect, or if we need to reset it
                if (!iconContainer || iconContainer.tagName !== 'SPAN' || !iconContainer.classList.contains('material-symbols-outlined')) {
                    // Recreate the standard icon span
                    var newIconSpan = document.createElement('span');
                    newIconSpan.className = 'material-symbols-outlined text-6xl mb-4 inline-block ' + iconClass;
                    newIconSpan.textContent = icon;

                    if (iconContainer) {
                        iconContainer.replaceWith(newIconSpan);
                    } else {
                        // Should be first child
                        statusCard.insertBefore(newIconSpan, statusCard.firstChild);
                    }
                } else {
                    // It's the standard span, just update it
                    iconContainer.textContent = icon;
                    iconContainer.className = 'material-symbols-outlined text-6xl mb-4 inline-block ' + iconClass;
                }
            }

            // Hide resume controls
            var resumeControls = document.getElementById('resume-controls');
            if (resumeControls) {
                resumeControls.style.display = 'none';
            }

            // Show secure exit if session ended
            var secureExitControls = document.getElementById('secure-exit-controls');
            if (secureExitControls && options.showExit) {
                secureExitControls.classList.remove('hidden');
            }
        }

        /**
         * Show transition loading overlay with optional message
         */
        function showTransitionOverlay(message) {
            var overlay = document.getElementById('transition-overlay');


            // Upgrade overlay content dynamically if it's the old simple version
            if (overlay && !overlay.querySelector('.animate-pulse-ring')) {
                overlay.innerHTML = `
                    <div class="flex flex-col items-center justify-center p-8">
                        <div class="relative w-20 h-20 mb-6 flex items-center justify-center">
                            <div class="absolute inset-0 rounded-full bg-veritas-navy/10 animate-pulse-ring"></div>
                            <div class="absolute inset-0 rounded-full bg-veritas-navy/5 animate-pulse-ring" style="animation-delay: 0.5s;"></div>
                            <div class="relative w-12 h-12 rounded-full bg-veritas-navy flex items-center justify-center shadow-lg transform transition-transform duration-500 hover:rotate-180">
                                <span class="material-symbols-outlined text-2xl text-white">sync</span>
                            </div>
                        </div>
                        <p id="transition-message" class="text-veritas-navy text-lg font-bold tracking-wide animate-text-shimmer">Loading...</p>
                        <p class="text-slate-400 text-xs font-medium mt-2 uppercase tracking-widest">Please Wait</p>
                    </div>
                `;
            }

            var msgEl = document.getElementById('transition-message');
            if (overlay) {
                overlay.style.display = 'flex';
                requestAnimationFrame(function () {
                    overlay.style.opacity = '1';
                });
            }
            if (msgEl) {
                var loadPhrases = [
                    "Synapsing...", "Calibrating Neural Net...", "Crunching Data...",
                    "Fetching Brilliance...", "Aligning Quarks...", "Beaming to Cloud..."
                ];
                msgEl.textContent = message || loadPhrases[Math.floor(Math.random() * loadPhrases.length)];
            }
        }

        /**
         * Hide transition loading overlay
         */
        function hideTransitionOverlay() {
            var overlay = document.getElementById('transition-overlay');
            if (overlay) {
                overlay.style.opacity = '0';
                setTimeout(function () {
                    overlay.style.display = 'none';
                }, 200);
            }
        }

        function showTeacherBlockedMessage() {
            console.log('Showing teacher block message');
            stopPolling();
            isInteractionBlocked = true;
            isTeacherBlocked = true;
            showStatusPanel({
                icon: 'pause_circle',
                iconClass: 'text-amber-600',
                message: 'Session Paused',
                messageClass: 'text-gray-900 text-xl font-semibold',
                subtext: 'Your teacher has temporarily frozen responses. Hold position.',
                subClass: 'text-gray-700 text-base mt-4',
                showResume: false,
                lockScroll: true
            });
        }

        function showResumePrompt() {
            console.log('Showing resume prompt');
            stopPolling();

            // CRITICAL FIX: Explicitly hide the lock overlay so the Resume prompt is visible
            hideLockEnforcementUI();

            var modeName = getFullModeName();
            var resumeLabel = document.getElementById('resume-session-label');
            if (resumeLabel) {
                resumeLabel.textContent = 'Resume ' + modeName;
            }
            showStatusPanel({
                theme: 'dark',
                icon: 'fullscreen',
                // iconClass: 'text-emerald-400', // Default is fine (emerald-400 set in function for dark mode)
                message: 'Cleared for Re-Entry',
                // messageClass: 'text-white text-3xl font-bold tracking-tight', // Default is fine
                subtext: 'Click below to return to fullscreen and rejoin the session.',
                // subClass: 'text-gray-300 text-lg mt-4', // Default is fine
                showResume: true,
                lockScroll: true
            });
        }

        function handleError(error) {
            console.error('Error:', error);

            // Extract clean error message
            var errorMsg = (error.message || error) || 'Unknown error';
            var errorString = String(errorMsg);

            // Remove "Error: " prefix if present to avoid duplication
            if (typeof errorMsg === 'string' && errorMsg.indexOf('Error: ') === 0) {
                errorMsg = errorMsg.substring(7);
            }

            // Handle generic network errors
            if (errorString.includes('NetworkError') || errorString.includes('HTTP 0') || errorString.includes('Connection failure')) {
                errorMsg = 'Network connection interrupted. Please check your internet connection and try again.';
            }

            showStatusPanel({
                icon: 'error',
                iconClass: 'text-veritas-navy',
                message: 'An error occurred: ' + errorMsg,
                messageClass: 'text-gray-900 text-2xl font-bold',
                showResume: false,
                lockScroll: false
            });
            if (resumeControls) resumeControls.style.display = 'none';
        }

        // =========================================================================
        // TI-84 CALCULATOR WIDGET MODULE
        // =========================================================================

        var calcFab = document.getElementById('calc-fab');
        var calcWindow = document.getElementById('calc-window');
        var calcHeader = document.getElementById('calc-header');
        var calcClose = document.getElementById('calc-close');
        var calcIframe = document.getElementById('calc-iframe');
        var calcLoader = document.getElementById('calc-loader');
        var calcIframeLoaded = false;
        var calcWindowOpen = false;

        /**
         * Sync calculator FAB visibility based on server state
         * @param {boolean} isEnabled - Whether calculator is enabled for this session
         */
        function syncCalculatorVisibility(isEnabled) {
            if (!calcFab) return;

            if (isEnabled) {
                calcFab.classList.remove('hidden');
            } else {
                calcFab.classList.add('hidden');
                // Force close calculator window if disabled mid-exam
                if (calcWindow) {
                    calcWindow.classList.add('hidden');
                    calcWindowOpen = false;
                }
            }
        }

        /**
         * Open calculator window and lazy-load iframe
         */
        function openCalculator() {
            if (!calcWindow || !calcIframe) return;

            calcWindow.classList.remove('hidden');
            calcWindowOpen = true;

            // Lazy load iframe on first open
            if (!calcIframeLoaded && calcIframe.dataset.src) {
                calcIframe.src = calcIframe.dataset.src;
                calcIframeLoaded = true;

                calcIframe.addEventListener('load', function () {
                    if (calcLoader) {
                        calcLoader.style.display = 'none';
                    }
                    console.log('[Calculator] TI-84 iframe loaded');
                }, { once: true });
            }
        }

        /**
         * Close calculator window
         */
        function closeCalculator() {
            if (!calcWindow) return;
            calcWindow.classList.add('hidden');
            calcWindowOpen = false;
        }

        // FAB click handler
        if (calcFab) {
            calcFab.addEventListener('click', function () {
                if (calcWindowOpen) {
                    closeCalculator();
                } else {
                    openCalculator();
                }
            });
        }

        // Close button handler
        if (calcClose) {
            calcClose.addEventListener('click', function (e) {
                e.stopPropagation();
                closeCalculator();
            });
        }

        // =========================================================================
        // DRAGGABLE WINDOW LOGIC (Robust Mouse + Touch Support)
        // =========================================================================

        // =========================================================================
        // ROBUST DRAG & DROP (Sovereign Shield Implementation)
        // =========================================================================

        function initCalculatorDrag() {
            var header = document.getElementById('calc-header');
            var win = document.getElementById('calc-window');
            var iframe = document.getElementById('calc-iframe');

            if (!header || !win) return;

            // Create Drag Shield (Lazy init)
            var shieldId = 'veritas-drag-shield';
            var shield = document.getElementById(shieldId);
            if (!shield) {
                shield = document.createElement('div');
                shield.id = shieldId;
                shield.style.position = 'fixed';
                shield.style.top = '0';
                shield.style.left = '0';
                shield.style.width = '100vw';
                shield.style.height = '100vh';
                shield.style.zIndex = '2147483647'; // Max z-index
                shield.style.cursor = 'move';
                shield.style.display = 'none';
                shield.style.background = 'transparent'; // Invisible
                document.body.appendChild(shield);
            }

            var isDragging = false;
            var startX, startY, initialLeft, initialTop;

            function onDragStart(e) {
                if (e.target.closest('#calc-close')) return;

                isDragging = true;

                // Show Shield to capture all mouse events (prevents iframe theft)
                shield.style.display = 'block';

                var clientX = e.type.indexOf('touch') !== -1 ? e.touches[0].clientX : e.clientX;
                var clientY = e.type.indexOf('touch') !== -1 ? e.touches[0].clientY : e.clientY;

                startX = clientX;
                startY = clientY;

                var rect = win.getBoundingClientRect();
                initialLeft = rect.left;
                initialTop = rect.top;

                // Clear transform, switch to static top/left for reliability
                win.style.transform = 'none';
                win.style.left = initialLeft + 'px';
                win.style.top = initialTop + 'px';
                win.style.right = 'auto';
                win.style.bottom = 'auto';

                if (e.cancelable && !e.target.tagName.match(/INPUT|TEXTAREA|SELECT|BUTTON/i)) {
                    e.preventDefault();
                }
            }

            function onDragMove(e) {
                if (!isDragging) return;

                // Prevent scrolling on touch
                if (e.cancelable) e.preventDefault();

                var clientX = e.type.indexOf('touch') !== -1 ? e.touches[0].clientX : e.clientX;
                var clientY = e.type.indexOf('touch') !== -1 ? e.touches[0].clientY : e.clientY;

                var deltaX = clientX - startX;
                var deltaY = clientY - startY;

                var newLeft = initialLeft + deltaX;
                var newTop = initialTop + deltaY;

                // Bounds Checking
                var maxW = window.innerWidth - win.offsetWidth;
                var maxH = window.innerHeight - win.offsetHeight;

                newLeft = Math.max(0, Math.min(newLeft, maxW));
                newTop = Math.max(0, Math.min(newTop, maxH));

                win.style.left = newLeft + 'px';
                win.style.top = newTop + 'px';
            }

            function onDragEnd() {
                isDragging = false;
                shield.style.display = 'none';
            }

            // Attach start listeners to header
            header.style.cursor = 'move';
            // Remove old listeners if any (by cloning? No, just add new ones, browser handles)
            // But to be clean, let's assume this runs once.
            header.addEventListener('mousedown', onDragStart);
            header.addEventListener('touchstart', onDragStart, { passive: false });

            // Attach move/end listeners to SHIELD (Sovereign Capture)
            // This is the key: The events happen on the shield, not the window/document
            shield.addEventListener('mousemove', onDragMove);
            shield.addEventListener('touchmove', onDragMove, { passive: false });

            shield.addEventListener('mouseup', onDragEnd);
            shield.addEventListener('touchend', onDragEnd);
            shield.addEventListener('mouseleave', onDragEnd);
        }

        // Initialize Drag
        function initVisuals() {
            // 1. Fix Question Header Initialization
            var qProgress = document.getElementById('question-progress');
            if (qProgress) {
                // Hide initially until a real question index is received
                qProgress.classList.add('hidden');
                qProgress.textContent = 'WAITING TO START';
            }

            // 2. Ghost Screen / Duplicate Logo Killer
            // The screenshot shows a duplicate "Veritas Live Polls" logo at the bottom.
            // This detects and removes duplicate entry screens or rogue H1s.
            var entryScreens = document.querySelectorAll('#entry-screen');
            if (entryScreens.length > 1) {
                console.warn('[VisualFix] Found ' + entryScreens.length + ' entry-screens. Removing duplicates.');
                for (var i = 1; i < entryScreens.length; i++) {
                    entryScreens[i].remove();
                }
            } else {
                // Fallback: If ID is missing on duplicates, check H1s
                var brands = document.querySelectorAll('h1');
                if (brands.length > 1) {
                    console.warn('[VisualFix] Found duplicate H1 elements. Cleaning up.');
                    for (var j = 1; j < brands.length; j++) {
                        // Traverse up to find the container to remove
                        var wrapper = brands[j].closest('.flex.items-center.gap-4'); // The logo container class
                        if (wrapper) wrapper.remove();
                        else brands[j].remove();
                    }
                }
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function () {
                initCalculatorDrag();
                initVisuals();
            });
        } else {
            initCalculatorDrag();
            initVisuals();
        }

        // Handle calculator visibility when session ends or locks
        function hideCalculatorOnSessionEnd() {
            var calcFab = document.getElementById('calc-fab');
            var calcWindow = document.getElementById('calc-window');
            if (calcFab) calcFab.style.display = 'none';
            if (calcWindow) {
                calcWindow.classList.add('hidden');
                calcWindow.classList.remove('active');
                calcWindow.style.display = 'none';
                calcWindowOpen = false;
            }
        }

        // Expose function for session state changes
        window.syncCalculatorVisibility = syncCalculatorVisibility;
        window.hideCalculatorOnSessionEnd = hideCalculatorOnSessionEnd;
        window.updateStudentView = updateStudentView;
        window.LockManager = LockManager;
        window.ViewManager = ViewManager;

    })();
</script>